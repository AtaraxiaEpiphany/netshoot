#!/usr/bin/env bash
set -euo pipefail

# Docker image delta transfer utility
# Efficiently transfer Docker images by delta encoding layers
# Supports xdelta3, bsdiff, and layer-only transfer methods

VERSION="1.0.0"

# ============================================================================
# Configuration and Constants
# ============================================================================

# Default settings
DELTA_METHOD="xdelta3"  # Choices: xdelta3, bsdiff, layer
VERBOSE=0
DRY_RUN=0
FORCE=0
COMPRESSION="zstd"  # Compress delta files: zstd, gzip, bzip2, xz, none
COMPRESSION_LEVEL=9

# Supported methods and formats
SUPPORTED_METHODS="xdelta3|bsdiff|layer"
SUPPORTED_COMPRESSION="zstd|gzip|bzip2|xz|none"

# Compression level ranges
ZSTD_MIN_LEVEL=-100
ZSTD_MAX_LEVEL=22
STD_MIN_LEVEL=1
STD_MAX_LEVEL=9

# Exit codes
EXIT_SUCCESS=0
EXIT_ERROR=1
EXIT_MISSING_DEPS=2
EXIT_INVALID_INPUT=3
EXIT_OPERATION_FAILED=4

# Color output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'       # No Color

# ============================================================================
# Logging Functions
# ============================================================================

# Error logging
error() {
    local exit_code=${2:-$EXIT_ERROR}
    echo -e "${RED}[ERROR]${NC} $1" >&2
    exit $exit_code
}

# Info logging
info() {
    echo -e "${GREEN}[INFO]${NC} $*"
}

# Verbose logging
verbose() {
    [[ $VERBOSE -eq 1 ]] && echo -e "${BLUE}[VERBOSE]${NC} $*" >&2
}

# ============================================================================
# Utility Functions
# ============================================================================

# Check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# ============================================================================
# Validation Functions
# ============================================================================

# Validate compression level based on format
validate_compression_level() {
    local format="$1"
    local level="$2"

    if [[ "$format" == "none" ]]; then
        return 0
    fi

    if [[ "$format" == "zstd" ]]; then
        if [[ "$level" -lt $ZSTD_MIN_LEVEL || "$level" -gt $ZSTD_MAX_LEVEL ]]; then
            error "Zstd level must be between $ZSTD_MIN_LEVEL and $ZSTD_MAX_LEVEL" $EXIT_INVALID_INPUT
        fi
    else
        if [[ "$level" -lt $STD_MIN_LEVEL || "$level" -gt $STD_MAX_LEVEL ]]; then
            error "Compression level must be between $STD_MIN_LEVEL and $STD_MAX_LEVEL" $EXIT_INVALID_INPUT
        fi
    fi
}

# Setup environment and check dependencies
setup_environment() {
    local missing_tools=()

    # Check required tools
    if ! command_exists "docker"; then
        missing_tools+=("docker")
    fi

    if ! command_exists "tar"; then
        missing_tools+=("tar")
    fi

    # Check file_delta in PATH or current directory
    if ! command_exists "file_delta"; then
        # Check if file_delta exists in script directory
        local script_dir
        script_dir=$(dirname "$(realpath "$0")")

        if [[ -x "$script_dir/file_delta" ]]; then
            PATH="$script_dir:$PATH"
            verbose "Using file_delta from script directory"
        else
            missing_tools+=("file_delta")
        fi
    fi

    if [[ ${#missing_tools[@]} -gt 0 ]]; then
        error "Missing required tools: ${missing_tools[*]}" $EXIT_MISSING_DEPS
    fi

    # Additional dependency check
    if ! command_exists "python3"; then
        error "Python3 is required for JSON processing" $EXIT_MISSING_DEPS
    fi

    verbose "All dependencies verified"
}

# Attempt Docker operation with retries
safe_docker_operation() {
    local cmd="$1"
    local max_retries=3
    local retry_wait=2

    for i in $(seq 1 $max_retries); do
        if $cmd; then
            return 0
        else
            verbose "Docker operation failed (attempt $i/$max_retries), retrying in $retry_wait seconds..."
            sleep $retry_wait
        fi
    done

    error "Docker operation failed after $max_retries attempts" $EXIT_OPERATION_FAILED
}

# Validate inputs
validate_inputs() {
    # Validate delta method
    case "$DELTA_METHOD" in
        xdelta3|bsdiff|layer) ;;
        *) error "Unsupported delta method: $DELTA_METHOD" $EXIT_INVALID_INPUT ;;
    esac

    # Validate compression format
    case "$COMPRESSION" in
        zstd|gzip|bzip2|xz|none) ;;
        *) error "Unsupported compression format: $COMPRESSION" $EXIT_INVALID_INPUT ;;
    esac

    # Validate compression level
    validate_compression_level "$COMPRESSION" "$COMPRESSION_LEVEL"
}

# ============================================================================
# Docker Image Functions
# ============================================================================

# Extract Docker image to temporary directory
extract_image_layers() {
    local image_name="$1"
    local extract_dir="$2"

    verbose "Extracting Docker image: $image_name"

    if [[ $DRY_RUN -eq 0 ]]; then
        mkdir -p "$extract_dir"

        # Enhanced debug logging
        verbose "Working directory: $(pwd)"
        verbose "Docker version: $(docker --version)"
        verbose "Docker image list:"
        docker image list | tee docker_images.log

        # Sanitize image name by removing quotes
        local sanitized_name=$(echo "$image_name" | tr -d '"')

        # Verify image exists first
        verbose "Checking for image: $sanitized_name"
        if ! docker image inspect "$sanitized_name" > /dev/null 2>&1; then
            error "Image '$sanitized_name' not found locally. See docker_images.log for available images." $EXIT_OPERATION_FAILED
        else
            verbose "Image found: $sanitized_name"
            docker image inspect "$sanitized_name" > image_inspect.json
        fi

        # Use sanitized name for all Docker operations
        image_name="$sanitized_name"

        # Create the tar archive with debug output
        verbose "Executing: docker save '$image_name' -o '$extract_dir/image.tar'"
        docker save "$image_name" -o "$extract_dir/image.tar" 2> docker_save_error.log || {
            error "Docker save failed. Error output:\n$(cat docker_save_error.log)\n" $EXIT_OPERATION_FAILED
        }

        # Verify output file
        if [[ ! -f "$extract_dir/image.tar" ]]; then
            error "Image tarball not created: $extract_dir/image.tar" $EXIT_OPERATION_FAILED
        else
            verbose "Image tarball created: $(du -h "$extract_dir/image.tar" | cut -f1)"
        fi

        # Extract tar contents
        tar -xf "$extract_dir/image.tar" -C "$extract_dir" || error "Failed to extract image tar" $EXIT_OPERATION_FAILED

        # Remove the tar file after extraction
        rm -f "$extract_dir/image.tar"

        verbose "Image extracted to: $extract_dir"
    fi
}

# Get image manifest
get_image_manifest() {
    local extract_dir="$1"
    local manifest_file="$extract_dir/manifest.json"

    if [[ ! -f "$manifest_file" ]]; then
        error "manifest.json not found in extracted image" $EXIT_OPERATION_FAILED
    fi

    echo "$manifest_file"
}

# Get layer list from manifest
get_layer_list() {
    local manifest_file="$1"

    # Extract layer digests from manifest.json
    # The manifest contains layers with their SHA256 digests
    python3 -c "
import json
import sys

with open('$manifest_file', 'r') as f:
    manifest = json.load(f)

# Get layers from the first manifest entry
if manifest and len(manifest) > 0:
    layers = manifest[0].get('Layers', [])
    for layer in layers:
        print(layer)
" 2>/dev/null || error "Failed to parse manifest.json" $EXIT_OPERATION_FAILED
}

# ============================================================================
# Delta Creation Functions
# ============================================================================

# Create delta for a single layer
create_layer_delta() {
    local old_layer="$1"
    local new_layer="$2"
    local delta_file="$3"

    # Create directory for delta file if it doesn't exist
    local delta_dir=$(dirname "$delta_file")
    if [[ $DRY_RUN -eq 0 ]]; then
        mkdir -p "$delta_dir" || error "Failed to create delta directory: $delta_dir" $EXIT_OPERATION_FAILED
    fi

    if [[ "$DELTA_METHOD" == "layer" ]]; then
        # Layer method: just copy the layer (no delta)
        verbose "Copying layer (layer method): $new_layer"
        if [[ $DRY_RUN -eq 0 ]]; then
            cp "$new_layer" "$delta_file" || error "Failed to copy layer" $EXIT_OPERATION_FAILED
        fi
    else
        # Use file_delta for xdelta3 or bsdiff
        verbose "Creating layer delta ($DELTA_METHOD): $old_layer -> $new_layer"

        if [[ $DRY_RUN -eq 0 ]]; then
            # Create delta using file_delta
            file_delta -m "$DELTA_METHOD" -c "$COMPRESSION" -l "$COMPRESSION_LEVEL" create \
                "$old_layer" "$new_layer" "$delta_file" || error "Failed to create layer delta" $EXIT_OPERATION_FAILED
        fi
    fi
}

# Create delta package for Docker image
create_delta_package() {
    local image_name="$1"
    local delta_package="$2"

    info "Creating delta package for image: $image_name"

    # Create temporary directory for extraction
    local temp_dir
    temp_dir=$(mktemp -d)
    trap "rm -rf '$temp_dir'" EXIT

    # Extract image layers with retry logic
    safe_docker_operation "extract_image_layers \"$image_name\" \"$temp_dir\""

    # Get manifest
    local manifest_file
    manifest_file=$(get_image_manifest "$temp_dir")

    # Get layer list
    local layers
    layers=$(get_layer_list "$manifest_file")

    # Create delta package directory
    local delta_dir
    delta_dir=$(mktemp -d)
    trap "rm -rf '$delta_dir'" EXIT
    mkdir -p "$delta_dir/layer_deltas"

    # Copy manifest
    cp "$manifest_file" "$delta_dir/manifest.json" || error "Failed to copy manifest" $EXIT_OPERATION_FAILED

    # Copy repositories file if exists
    if [[ -f "$temp_dir/repositories" ]]; then
        cp "$temp_dir/repositories" "$delta_dir/repositories" || error "Failed to copy repositories" $EXIT_OPERATION_FAILED
    fi

    # Create metadata
    cat > "$delta_dir/metadata.json" << EOF
{
    "version": "$VERSION",
    "delta_method": "$DELTA_METHOD",
    "compression": "$COMPRESSION",
    "compression_level": $COMPRESSION_LEVEL,
    "image_name": "$image_name",
    "created_at": "$(date -Iseconds)"
}
EOF

    # Process each layer
    local layer_count=0
    while IFS= read -r layer; do
        if [[ -n "$layer" ]]; then
            layer_count=$((layer_count + 1))
            local layer_file="$temp_dir/$layer"
            local delta_file="$delta_dir/layer_deltas/${layer}.delta"

            info "Processing layer $layer_count: $layer"

            if [[ "$DELTA_METHOD" == "layer" ]]; then
                # Layer method: just copy the layer
                create_layer_delta "" "$layer_file" "$delta_file"
            else
                # For xdelta3/bsdiff, we need an old version to create delta
                # Since we don't have an old version, we'll use an empty file as baseline
                local empty_file
                empty_file=$(mktemp)
                trap "rm -f '$empty_file'" EXIT

                create_layer_delta "$empty_file" "$layer_file" "$delta_file"
                rm -f "$empty_file"
            fi
        fi
    done <<< "$layers"

    # Create the delta package tar
    info "Creating delta package: $delta_package"

    if [[ $DRY_RUN -eq 0 ]]; then
        # Handle existing delta package
        if [ -e "$delta_package" ]; then
            if [[ $FORCE -eq 1 ]]; then
                verbose "Removing existing delta package: $delta_package"
                rm -f "$delta_package"
            else
                error "Delta package already exists: $delta_package. Use -f to force overwrite." $EXIT_INVALID_INPUT
            fi
        fi

        # Create tar archive
        tar -czf "$delta_package" -C "$delta_dir" . || error "Failed to create delta package" $EXIT_OPERATION_FAILED

        # Get package size
        local package_size
        package_size=$(du -h "$delta_package" | cut -f1)
        info "Delta package created: $delta_package ($package_size)"
        info "Layers processed: $layer_count"
    fi
}

# ============================================================================
# Delta Application Functions
# ============================================================================

# Apply delta to reconstruct a layer
apply_layer_delta() {
    local old_layer="$1"
    local delta_file="$2"
    local new_layer="$3"

    if [[ "$DELTA_METHOD" == "layer" ]]; then
        # Layer method: just copy the delta (which is the layer itself)
        verbose "Copying layer (layer method): $delta_file -> $new_layer"
        if [[ $DRY_RUN -eq 0 ]]; then
            cp "$delta_file" "$new_layer" || error "Failed to copy layer" $EXIT_OPERATION_FAILED
        fi
    else
        # Use file_delta to apply delta
        verbose "Applying layer delta ($DELTA_METHOD): $old_layer + $delta_file -> $new_layer"

        if [[ $DRY_RUN -eq 0 ]]; then
            # Apply delta using file_delta
            file_delta -m "$DELTA_METHOD" apply "$old_layer" "$delta_file" "$new_layer" || \
                error "Failed to apply layer delta" $EXIT_OPERATION_FAILED
        fi
    fi
}

# Apply delta package to reconstruct Docker image
apply_delta_package() {
    local delta_package="$1"
    local image_name="${2:-}"

    info "Applying delta package: $delta_package"

    # Check if delta package exists
    if [[ ! -f "$delta_package" ]]; then
        error "Delta package not found: $delta_package" $EXIT_INVALID_INPUT
    fi

    # Create temporary directory for extraction
    local temp_dir
    temp_dir=$(mktemp -d)
    trap "rm -rf '$temp_dir'" EXIT

    # Extract delta package
    verbose "Extracting delta package"
    tar -xzf "$delta_package" -C "$temp_dir" || error "Failed to extract delta package" $EXIT_OPERATION_FAILED

    # Read metadata
    local metadata_file="$temp_dir/metadata.json"
    if [[ ! -f "$metadata_file" ]]; then
        error "metadata.json not found in delta package" $EXIT_OPERATION_FAILED
    fi

    # Extract delta method from metadata
    local package_delta_method
    package_delta_method=$(python3 -c "
import json
with open('$metadata_file', 'r') as f:
    metadata = json.load(f)
    print(metadata.get('delta_method', 'xdelta3'))
" 2>/dev/null)

    # Extract compression from metadata
    local package_compression
    package_compression=$(python3 -c "
import json
with open('$metadata_file', 'r') as f:
    metadata = json.load(f)
    print(metadata.get('compression', 'zstd'))
" 2>/dev/null)
    local package_compression_level
    package_compression_level=$(python3 -c "
import json
with open('$metadata_file', 'r') as f:
    metadata = json.load(f)
    print(metadata.get('compression_level', 9))
" 2>/dev/null)

    verbose "Delta method: $package_delta_method"
    verbose "Compression: $package_compression level $package_compression_level"

    # Get manifest
    local manifest_file="$temp_dir/manifest.json"
    if [[ ! -f "$manifest_file" ]]; then
        error "manifest.json not found in delta package" $EXIT_OPERATION_FAILED
    fi

    # Get layer list from manifest
    local layers
    layers=$(get_layer_list "$manifest_file")

    # Create image directory for reconstruction
    local image_dir
    image_dir=$(mktemp -d)
    trap "rm -rf '$image_dir'" EXIT

    # Process each layer delta
    local layer_count=0
    while IFS= read -r layer; do
        if [[ -n "$layer" ]]; then
            layer_count=$((layer_count + 1))
            local delta_file="$temp_dir/layer_deltas/${layer}.delta"
            local layer_file="$image_dir/$layer"

            info "Reconstructing layer $layer_count: $layer"

            if [[ "$package_delta_method" == "layer" ]]; then
                # Layer method: just copy the delta (which is the layer itself)
                apply_layer_delta "" "$delta_file" "$layer_file"
            else
                # For xdelta3/bsdiff, we need an old version to apply delta
                # Since we don't have an old version, we'll use an empty file as baseline
                local empty_file
                empty_file=$(mktemp)
                trap "rm -f '$empty_file'" EXIT

                apply_layer_delta "$empty_file" "$delta_file" "$layer_file"
                rm -f "$empty_file"
            fi
        fi
    done <<< "$layers"

    # Copy manifest and repositories
    cp "$manifest_file" "$image_dir/manifest.json" || error "Failed to copy manifest" $EXIT_OPERATION_FAILED
    if [[ -f "$temp_dir/repositories" ]]; then
        cp "$temp_dir/repositories" "$image_dir/repositories" || error "Failed to copy repositories" $EXIT_OPERATION_FAILED
    fi

    # Create tar archive for docker load
    local image_tar
    image_tar=$(mktemp)
    trap "rm -f '$image_tar'" EXIT

    info "Creating Docker image tar"
    tar -cf "$image_tar" -C "$image_dir" . || error "Failed to create image tar" $EXIT_OPERATION_FAILED

    # Load the image
    info "Loading Docker image"
    if [[ $DRY_RUN -eq 0 ]]; then
        docker load -i "$image_tar" || error "Failed to load Docker image" $EXIT_OPERATION_FAILED

        # Get the image name from metadata if not provided
        if [[ -z "$image_name" ]]; then
            image_name=$(python3 -c "
import json
with open('$metadata_file', 'r') as f:
    metadata = json.load(f)
    print(metadata.get('image_name', ''))
")
        fi

        if [[ -n "$image_name" ]]; then
            info "Image loaded successfully: $image_name"
        else
            info "Image loaded successfully"
        fi
    fi
}

# ============================================================================
# Delta Package Info Functions
# ============================================================================

# List layers in delta package
list_delta_package() {
    local delta_package="$1"

    if [[ ! -f "$delta_package" ]]; then
        error "Delta package not found: $delta_package" $EXIT_INVALID_INPUT
    fi

    # Create temporary directory for extraction
    local temp_dir
    temp_dir=$(mktemp -d)
    trap "rm -rf '$temp_dir'" EXIT

    # Extract delta package
    tar -xzf "$delta_package" -C "$temp_dir" || error "Failed to extract delta package" $EXIT_OPERATION_FAILED

    # Read metadata
    local metadata_file="$temp_dir/metadata.json"
    if [[ -f "$metadata_file" ]]; then
        info "Delta Package Metadata:"
        cat "$metadata_file" | python3 -m json.tool 2>/dev/null || cat "$metadata_file"
        echo ""
    fi

    # Get manifest
    local manifest_file="$temp_dir/manifest.json"
    if [[ ! -f "$manifest_file" ]]; then
        error "manifest.json not found in delta package" $EXIT_OPERATION_FAILED
    fi

    # List layers
    info "Layers in delta package:"
    local layer_count=0
    local layers
    layers=$(get_layer_list "$manifest_file")

    while IFS= read -r layer; do
        if [[ -n "$layer" ]]; then
            layer_count=$((layer_count + 1))
            local delta_file="$temp_dir/layer_deltas/${layer}.delta"
            local delta_size
            if [[ -f "$delta_file" ]]; then
                delta_size=$(du -h "$delta_file" | cut -f1)
            else
                delta_size="N/A"
            fi
            echo "  $layer_count. $layer ($delta_size)"
        fi
    done <<< "$layers"

    info "Total layers: $layer_count"
}

# Show delta package info
show_delta_info() {
    local delta_package="$1"

    if [[ ! -f "$delta_package" ]]; then
        error "Delta package not found: $delta_package" $EXIT_INVALID_INPUT
    fi

    # Get package size
    local package_size
    package_size=$(du -h "$delta_package" | cut -f1)

    info "Delta Package: $delta_package"
    info "Size: $package_size"

    # Create temporary directory for extraction
    local temp_dir
    temp_dir=$(mktemp -d)
    trap "rm -rf '$temp_dir'" EXIT

    # Extract delta package
    tar -xzf "$delta_package" -C "$temp_dir" || error "Failed to extract delta package" $EXIT_OPERATION_FAILED

    # Read metadata
    local metadata_file="$temp_dir/metadata.json"
    if [[ -f "$metadata_file" ]]; then
        info "Metadata:"
        cat "$metadata_file" | python3 -m json.tool 2>/dev/null || cat "$metadata_file"
    fi
}

# ============================================================================
# CLI Interface
# ============================================================================

# Print usage information
usage() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS] ACTION [ARGS...]

Docker image delta transfer utility for efficient offline transfers.
Transfers only changed layers instead of complete images.

Actions:
  create IMAGE_NAME DELTA_PACKAGE    Create delta package from Docker image
  apply DELTA_PACKAGE [IMAGE_NAME]   Apply delta package to reconstruct image
  list DELTA_PACKAGE                 List layers in delta package
  info DELTA_PACKAGE                 Show delta package metadata

Delta Methods:
  xdelta3   Binary delta for each layer (default, smallest transfer size)
  bsdiff    High-quality delta for large layer changes
  layer     Transfer complete layer files (no delta, just compression)

Options:
  -m, --method METHOD        Delta method: xdelta3 (default), bsdiff, layer
  -c, --compression FORMAT   Compress delta: zstd (default), gzip, bzip2, xz, none
  -l, --level LEVEL          Compression level (1-9, or -1 to -100 for zstd fast mode)
  -v, --verbose              Show detailed operation info
  -d, --dry-run              Simulate operation without making changes
  -f, --force                Overwrite existing delta/target files
  -h, --help                 Display this help message
  --version                  Show script version

Examples:
  # Create delta package from Docker image
  $0 create nginx:latest nginx.delta.tar.gz

  # Apply delta package to reconstruct image
  $0 apply nginx.delta.tar.gz

  # List layers in delta package
  $0 list nginx.delta.tar.gz

  # Show delta package info
  $0 info nginx.delta.tar.gz

  # Create delta with bsdiff method
  $0 -m bsdiff create myapp:v2 myapp.delta.tar.gz

  # Create uncompressed delta (layer method only)
  $0 -m layer -c none create myimage:v1 image.delta.tar

  # Verbose dry run
  $0 -vd create myimage:v2 test.delta.tar.gz

Dependencies:
  Required: docker, tar, file_delta, python3 (for JSON parsing)
  Optional: zstd, gzip, bzip2, xz (for compression)

Notes:
  - The delta package contains layer deltas and image metadata
  - For xdelta3/bsdiff methods, an empty file is used as baseline
  - Layer method transfers complete layers without delta encoding
  - Use 'list' action to preview layers before applying
EOF
    exit $EXIT_SUCCESS
}

# Parse command-line arguments
parse_args() {
    # Pre-process combined short options like -vd -> -v -d
    local args=()
    while [[ $# -gt 0 ]]; do
        if [[ "$1" =~ ^-[^-].{2,}$ ]]; then
            local flags="${1:1}"
            for ((i=0; i<${#flags}; i++)); do
                args+=("-"${flags:$i:1})
            done
        else
            args+=("$1")
        fi
        shift
    done

    TEMP=$(getopt -o m:c:l:vdh --long method:,compression:,level:,verbose,dry-run,help,version -n "$0" -- "${args[@]}")

    if [ $? != 0 ] ; then error "Terminating..." $EXIT_ERROR ; exit $EXIT_ERROR ; fi

    eval set -- "$TEMP"

    while true; do
        case "$1" in
            -m|--method)
                DELTA_METHOD="$2"
                shift 2
                ;;
            -c|--compression)
                COMPRESSION="$2"
                shift 2
                ;;
            -l|--level)
                COMPRESSION_LEVEL="$2"
                shift 2
                ;;
            -v|--verbose)
                VERBOSE=1
                shift
                ;;
            -d|--dry-run)
                DRY_RUN=1
                shift
                ;;
            -f|--force)
                FORCE=1
                shift
                ;;
            -h|--help)
                usage
                ;;
            --version)
                echo "docker_delta version $VERSION"
                exit $EXIT_SUCCESS
                ;;
            --)
                shift
                break
                ;;
            *)
                error "Internal error!" $EXIT_ERROR
                ;;
        esac
    done

    if [ $# -lt 1 ]; then
        error "Missing action. Use -h for help." $EXIT_INVALID_INPUT
    fi

    ACTION="$1"
    shift

    case "$ACTION" in
        create)
            if [ $# -lt 2 ]; then
                error "Missing arguments for create. Use -h for help." $EXIT_INVALID_INPUT
            fi
            IMAGE_NAME="$1"
            DELTA_PACKAGE="$2"
            ;;
        apply)
            if [ $# -lt 1 ]; then
                error "Missing arguments for apply. Use -h for help." $EXIT_INVALID_INPUT
            fi
            DELTA_PACKAGE="$1"
            IMAGE_NAME="${2:-}"
            ;;
        list|info)
            if [ $# -lt 1 ]; then
                error "Missing arguments for $ACTION. Use -h for help." $EXIT_INVALID_INPUT
            fi
            DELTA_PACKAGE="$1"
            ;;
        *)
            error "Invalid action: $ACTION. Must be 'create', 'apply', 'list', or 'info'." $EXIT_INVALID_INPUT
            ;;
    esac
}

# Main function
main() {
    parse_args "$@"
    validate_inputs
    setup_environment

    verbose "docker_delta version $VERSION"
    verbose "Action: $ACTION"
    verbose "Delta Method: $DELTA_METHOD"
    verbose "Compression: $COMPRESSION"
    if [[ "$COMPRESSION" != "none" ]]; then
        verbose "Compression Level: $COMPRESSION_LEVEL"
    fi

    case "$ACTION" in
        create)
            create_delta_package "$IMAGE_NAME" "$DELTA_PACKAGE"
            ;;
        apply)
            apply_delta_package "$DELTA_PACKAGE" "$IMAGE_NAME"
            ;;
        list)
            list_delta_package "$DELTA_PACKAGE"
            ;;
        info)
            show_delta_info "$DELTA_PACKAGE"
            ;;
    esac

    if [[ $DRY_RUN -eq 1 ]]; then
        verbose "Dry run completed successfully"
    else
        verbose "Operation completed successfully"
    fi
}

# Run the script
main "$@"

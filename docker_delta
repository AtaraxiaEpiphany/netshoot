#!/usr/bin/env bash
set -euo pipefail

# Docker image delta transfer utility
# Efficiently transfer Docker images by delta encoding layers
# Supports xdelta3, bsdiff, and layer-only transfer methods

VERSION="1.0.0"

# ============================================================================
# Configuration and Constants
# ============================================================================

# Default settings
DELTA_METHOD="xdelta3"  # Choices: xdelta3, bsdiff, layer
VERBOSE=0
DRY_RUN=0
FORCE=0
COMPRESSION="zstd"  # Compress delta files: zstd, gzip, bzip2, xz, none
COMPRESSION_LEVEL=9

# Skopeo integration settings
USE_SKOPEO=0              # Flag for using Skopeo (0 = Docker daemon, 1 = local file)
IMAGE_FILE=""              # Path to local image file
SOURCE_FORMAT=""           # Source format: docker-archive, oci-archive
TARGET_FORMAT=""           # Target format: docker-archive, oci-archive
PLATFORM_ARCH=""           # Architecture for multi-arch images
PLATFORM_OS=""            # OS for multi-arch images

# Supported methods and formats
SUPPORTED_METHODS="xdelta3|bsdiff|layer"
SUPPORTED_COMPRESSION="zstd|gzip|bzip2|xz|none"

# Compression level ranges
ZSTD_MIN_LEVEL=-100
ZSTD_MAX_LEVEL=22
STD_MIN_LEVEL=1
STD_MAX_LEVEL=9

# Exit codes
EXIT_SUCCESS=0
EXIT_ERROR=1
EXIT_MISSING_DEPS=2
EXIT_INVALID_INPUT=3
EXIT_OPERATION_FAILED=4

# Color output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'       # No Color

# ============================================================================
# Logging Functions
# ============================================================================

# Error logging
error() {
    local exit_code=${2:-$EXIT_ERROR}
    local error_msg="${RED}[ERROR]${NC} $(date +'%Y-%m-%d %H:%M:%S') $1"
    echo -e "$error_msg" >&2

    # Log to error log file if available
    if [[ -w "/var/log" ]]; then
        echo "$error_msg" >> "/var/log/docker_delta_errors.log" 2>/dev/null
    fi

    exit $exit_code
}

# Info logging
info() {
    echo -e "${GREEN}[INFO]${NC} $*"
}

# Verbose logging
verbose() {
    [[ $VERBOSE -eq 1 ]] && echo -e "${BLUE}[VERBOSE $(date +'%Y-%m-%d %H:%M:%S')]${NC} $*" >&2
}

# ============================================================================
# Utility Functions
# ============================================================================

# Check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# ============================================================================
# Image Source Detection Functions
# ============================================================================

# Detect if image source is a local file or Docker daemon image
detect_image_source() {
    local source="$1"
    # Remove quotes if present
    local cleaned_source=$(echo "$source" | tr -d '"')

    # Debug: Show what we're checking
    verbose "Checking if '$cleaned_source' exists as a file..."
    if [[ -f "$cleaned_source" ]]; then
        USE_SKOPEO=1
        IMAGE_FILE="$cleaned_source"
        verbose "Detected local image file: $cleaned_source"
    else
        USE_SKOPEO=0
        verbose "Detected Docker daemon image: $source"
    fi
}

# Detect image file format based on file extension
detect_image_format() {
    local file="$1"

    if [[ "$file" == *.tar.gz ]] || [[ "$file" == *.tgz ]]; then
        echo "oci-archive"
    elif [[ "$file" == *.tar ]]; then
        echo "docker-archive"
    else
        # Default to docker-archive for unknown extensions
        echo "docker-archive"
    fi
}

# Get Skopeo transport URL for image file
get_skopeo_transport() {
    local file="$1"
    local format="${2:-}"

    if [[ -z "$format" ]]; then
        format=$(detect_image_format "$file")
    fi

    echo "${format}://${file}"
}

# ============================================================================
# Validation Functions
# ============================================================================

# Validate compression level based on format
validate_compression_level() {
    local format="$1"
    local level="$2"

    if [[ "$format" == "none" ]]; then
        return 0
    fi

    if [[ "$format" == "zstd" ]]; then
        if [[ "$level" -lt $ZSTD_MIN_LEVEL || "$level" -gt $ZSTD_MAX_LEVEL ]]; then
            error "Zstd level must be between $ZSTD_MIN_LEVEL and $ZSTD_MAX_LEVEL" $EXIT_INVALID_INPUT
        fi
    else
        if [[ "$level" -lt $STD_MIN_LEVEL || "$level" -gt $STD_MAX_LEVEL ]]; then
            error "Compression level must be between $STD_MIN_LEVEL and $STD_MAX_LEVEL" $EXIT_INVALID_INPUT
        fi
    fi
}

# Setup environment and check dependencies
setup_environment() {
    local missing_tools=()

    # Check required tools for Docker daemon operations
    if [[ $USE_SKOPEO -eq 0 ]]; then
        if ! command_exists "docker"; then
            missing_tools+=("docker")
        fi
    fi

    if ! command_exists "tar"; then
        missing_tools+=("tar")
    fi

    # Check file_delta in PATH or current directory
    if ! command_exists "file_delta"; then
        # Check if file_delta exists in script directory
        local script_dir
        script_dir=$(dirname "$(realpath "$0")")

        if [[ -x "$script_dir/file_delta" ]]; then
            PATH="$script_dir:$PATH"
            verbose "Using file_delta from script directory"
        else
            missing_tools+=("file_delta")
        fi
    fi

    # Check Skopeo for local file operations
    if [[ $USE_SKOPEO -eq 1 ]]; then
        if ! command_exists "skopeo"; then
            error "Skopeo is required for local image file operations" $EXIT_MISSING_DEPS
        fi
        verbose "Using Skopeo for local image file operations"
    else
        verbose "Using Docker daemon for image operations"
    fi

    if [[ ${#missing_tools[@]} -gt 0 ]]; then
        error "Missing required tools: ${missing_tools[*]}" $EXIT_MISSING_DEPS
    fi

    # Additional dependency check
    if ! command_exists "python3"; then
        error "Python3 is required for JSON processing" $EXIT_MISSING_DEPS
    fi

    verbose "All dependencies verified"
}

# Attempt Docker operation with retries
safe_docker_operation() {
    local cmd="$1"
    local max_retries=3
    local retry_wait=2

    for i in $(seq 1 $max_retries); do
        if $cmd; then
            return 0
        else
            verbose "Docker operation failed (attempt $i/$max_retries), retrying in $retry_wait seconds..."
            sleep $retry_wait
        fi
    done

    error "Docker operation failed after $max_retries attempts" $EXIT_OPERATION_FAILED
}

# Validate inputs
validate_inputs() {
    # Validate delta method
    case "$DELTA_METHOD" in
        xdelta3|bsdiff|layer) ;;
        *) error "Unsupported delta method: $DELTA_METHOD" $EXIT_INVALID_INPUT ;;
    esac

    # Validate compression format
    case "$COMPRESSION" in
        zstd|gzip|bzip2|xz|none) ;;
        *) error "Unsupported compression format: $COMPRESSION" $EXIT_INVALID_INPUT ;;
    esac

    # Validate compression level
    validate_compression_level "$COMPRESSION" "$COMPRESSION_LEVEL"
}

# ============================================================================
# Docker Image Functions
# ============================================================================

# Extract image layers using Skopeo (for local image files)
# Arguments:
#   $1 - Path to local image file
#   $2 - Directory to extract layers to
#   $3 - Optional: image format (docker-archive, oci-archive)
# Returns:
#   None, but extracts layers to specified directory
# Exit codes:
#   EXIT_OPERATION_FAILED - If Skopeo copy fails
extract_layers_skopeo() {
    local image_file="$1"
    local extract_dir="$2"
    local format="${3:-}"

    if [[ -z "$format" ]]; then
        format=$(detect_image_format "$image_file")
    fi

    verbose "Extracting layers from local image file: $image_file (format: $format)"

    if [[ $DRY_RUN -eq 0 ]]; then
        mkdir -p "$extract_dir"

        # Debug: Check extract directory creation
        verbose "Created extract directory: $extract_dir"
        ls -la "$extract_dir"

        # Build Skopeo copy command with platform options if specified
        local skopeo_cmd="skopeo copy --dest-tls-verify=false"

        if [[ -n "$PLATFORM_ARCH" ]]; then
            skopeo_cmd="$skopeo_cmd --override-arch=$PLATFORM_ARCH"
        fi

        if [[ -n "$PLATFORM_OS" ]]; then
            skopeo_cmd="$skopeo_cmd --override-os=$PLATFORM_OS"
        fi

        # Copy image to OCI directory format for easier layer access
        # Use absolute path to avoid Skopeo path issues
        local absolute_image_file=$(realpath "$image_file")
        local transport_url="$format://$absolute_image_file"
        local dest_url="oci://$extract_dir"
        verbose "Executing: $skopeo_cmd '$transport_url' '$dest_url'"

        # Execute Skopeo command directly without eval to avoid quote issues
        $skopeo_cmd "$transport_url" "$dest_url" || \
            error "Skopeo copy failed" $EXIT_OPERATION_FAILED

        # Debug: Show what Skopeo created
        verbose "Skopeo copy completed, directory structure:"
        ls -la "$extract_dir"
        find "$extract_dir" -name "*.json" -o -name "*.blob" -o -name "sha256:*" | head -20

        verbose "Image layers extracted to: $extract_dir"
    fi
}

# Get image manifest using Skopeo (for local image files)
get_manifest_skopeo() {
    local image_file="$1"
    local format="${2:-}"

    if [[ -z "$format" ]]; then
        format=$(detect_image_format "$image_file")
    fi

    verbose "Getting manifest from local image file: $image_file"

    local transport_url=$(get_skopeo_transport "$image_file" "$format")

    # Build Skopeo inspect command with platform options if specified
    local skopeo_cmd="skopeo inspect --raw"

    if [[ -n "$PLATFORM_ARCH" ]]; then
        skopeo_cmd="$skopeo_cmd --override-arch=$PLATFORM_ARCH"
    fi

    if [[ -n "$PLATFORM_OS" ]]; then
        skopeo_cmd="$skopeo_cmd --override-os=$PLATFORM_OS"
    fi

    verbose "Executing: $skopeo_cmd '$transport_url'"

    eval "$skopeo_cmd '$transport_url'" || \
        error "Skopeo inspect failed" $EXIT_OPERATION_FAILED
}

# Extract Docker image to temporary directory
extract_image_layers() {
    local image_source="$1"
    local extract_dir="$2"

    # Detect if source is a local file or Docker daemon image
    # Debug: Print image source before detection
    verbose "Image source before detection: '$image_source'"
    detect_image_source "$image_source"

    if [[ $USE_SKOPEO -eq 1 ]]; then
        # Use Skopeo for local image file
        extract_layers_skopeo "$IMAGE_FILE" "$extract_dir" "$SOURCE_FORMAT"
    else
        # Use Docker daemon for loaded image
        verbose "Extracting Docker image: $image_source"

        if [[ $DRY_RUN -eq 0 ]]; then
            mkdir -p "$extract_dir"

            # Enhanced debug logging
            verbose "Working directory: $(pwd)"
            verbose "Docker version: $(docker --version)"
            verbose "Docker image list:"
            docker image list | tee docker_images.log

            # Sanitize image name by removing quotes
            local sanitized_name=$(echo "$image_source" | tr -d '"')

            # Verify image exists first
            verbose "Checking for image: $sanitized_name"
            if ! docker image inspect "$sanitized_name" > /dev/null 2>&1; then
                error "Image '$sanitized_name' not found locally. See docker_images.log for available images." $EXIT_OPERATION_FAILED
            else
                verbose "Image found: $sanitized_name"
                docker image inspect "$sanitized_name" > image_inspect.json
            fi

            # Use sanitized name for all Docker operations
            image_source="$sanitized_name"

            # Create the tar archive with debug output
            verbose "Executing: docker save '$image_source' -o '$extract_dir/image.tar'"
            docker save "$image_source" -o "$extract_dir/image.tar" 2> docker_save_error.log || {
                error "Docker save failed. Error output:\n$(cat docker_save_error.log)\n" $EXIT_OPERATION_FAILED
            }

            # Verify output file
            if [[ ! -f "$extract_dir/image.tar" ]]; then
                error "Image tarball not created: $extract_dir/image.tar" $EXIT_OPERATION_FAILED
            else
                verbose "Image tarball created: $(du -h "$extract_dir/image.tar" | cut -f1)"
            fi

            # Extract tar contents
            # New Docker versions save in OCI format, old in Docker format
            tar -xf "$extract_dir/image.tar" -C "$extract_dir" || error "Failed to extract image tar" $EXIT_OPERATION_FAILED

            # Check for different formats
            if [[ ! -f "$extract_dir/manifest.json" ]] && [[ -f "$extract_dir/index.json" ]]; then
                # This is OCI format - create the expected directories
                mkdir -p "$extract_dir/blobs/sha256"
                mv "$extract_dir"/*.json "$extract_dir/blobs/sha256" 2>/dev/null || true
            fi

            # Remove the tar file after extraction
            rm -f "$extract_dir/image.tar"

            verbose "Image extracted to: $extract_dir"
        fi
    fi
}

# Get image manifest
get_image_manifest() {
    local extract_dir="$1"
    local manifest_file

    # Check if it's OCI format directory structure
    if [[ -f "$extract_dir/index.json" && -d "$extract_dir/blobs" ]]; then
        # Skopeo copies OCI format to this structure
        echo "$extract_dir/index.json"
    # Check if it's Docker format
    elif [[ -f "$extract_dir/manifest.json" ]]; then
        echo "$extract_dir/manifest.json"
    else
        # Search for manifest file in various locations
        manifest_file=$(find "$extract_dir" -name "manifest.json" -o -name "index.json" | head -1)
        if [[ -n "$manifest_file" ]]; then
            echo "$manifest_file"
        else
            error "No manifest found in extracted image at $extract_dir" $EXIT_OPERATION_FAILED
        fi
    fi
}

# Get layer list from manifest
get_layer_list() {
    local manifest_file="$1"
    local layers_output=""

    # Handle case where manifest_file might be empty
    if [[ -z "$manifest_file" ]]; then
        error "No manifest file provided" $EXIT_OPERATION_FAILED
    fi

    # Parse manifest file for layer information (most reliable source)
    if [[ -f "$manifest_file" ]]; then
        # Detect manifest format by content rather than filename
        if jq -e '.manifests' "$manifest_file" >/dev/null 2>&1; then
            # This is an index manifest (contains .manifests array)
            verbose "Processing OCI index manifest: $manifest_file"

            local manifest_digest=""
            # Try to find manifest matching platform (if specified)
            if [[ -n "$PLATFORM_ARCH" && -n "$PLATFORM_OS" ]]; then
                verbose "Looking for $PLATFORM_OS/$PLATFORM_ARCH manifest"
                manifest_digest=$(jq -r --arg os "$PLATFORM_OS" --arg arch "$PLATFORM_ARCH" \
                    '.manifests[] | select(.platform.os == $os and .platform.architecture == $arch) | .digest' "$manifest_file" 2>/dev/null | cut -d: -f2 || true)
            fi

            # If no platform specified or no matching manifest, use first amd64/linux manifest
            if [[ -z "$manifest_digest" ]]; then
                verbose "Using default amd64/linux manifest"
                manifest_digest=$(jq -r \
                    '.manifests[] | select(.platform.os == "linux" and .platform.architecture == "amd64") | .digest' "$manifest_file" 2>/dev/null | cut -d: -f2 || true)
            fi

            # If still no manifest, use first manifest in list
            if [[ -z "$manifest_digest" ]]; then
                verbose "Using first manifest in index"
                manifest_digest=$(jq -r '.manifests[0].digest' "$manifest_file" 2>/dev/null | cut -d: -f2 || true)
            fi

            if [[ -n "$manifest_digest" ]]; then
                local actual_manifest=""
                # Check if manifest file is already in blobs directory
                if [[ "$manifest_file" == */blobs/sha256/* ]]; then
                    actual_manifest="${manifest_file%/*}/${manifest_digest}"
                else
                    actual_manifest="${manifest_file%/*}/blobs/sha256/${manifest_digest}"
                fi
                verbose "Found actual manifest: $actual_manifest"

                if [[ -f "$actual_manifest" ]]; then
                    # Try to extract layers from actual manifest
                    layers_output=$(jq -r '.layers[].digest' "$actual_manifest" 2>/dev/null | sed 's/sha256://' || true)

                    # If no layers found, this might be another index or not an image manifest
                    if [[ -z "$layers_output" ]]; then
                        verbose "No layers found in manifest, checking if it's another index..."
                        # Check if this is another index
                        if jq -e '.manifests' "$actual_manifest" >/dev/null 2>&1; then
                            verbose "This is another index file, recursively processing..."
                            layers_output=$(get_layer_list "$actual_manifest")
                        else
                            error "Manifest file $actual_manifest does not contain layers" $EXIT_OPERATION_FAILED
                        fi
                    fi
                else
                    error "Actual manifest file not found: $actual_manifest" $EXIT_OPERATION_FAILED
                fi
            else
                error "No valid manifest found in index file" $EXIT_OPERATION_FAILED
            fi
        elif jq -e '.layers' "$manifest_file" >/dev/null 2>&1; then
            # This is an image manifest (contains .layers array)
            verbose "Processing OCI image manifest: $manifest_file"
            layers_output=$(jq -r '.layers[].digest' "$manifest_file" 2>/dev/null | sed 's/sha256://' || true)
        elif jq -e '.[0]?.Layers' "$manifest_file" >/dev/null 2>&1; then
            # Docker format manifest (legacy format)
            verbose "Processing Docker manifest: $manifest_file"
            # Extract layers from manifest - handle both single and multiple image formats
            layers_output=$(jq -r '.[0].Layers[]' "$manifest_file" 2>/dev/null || true)
            if [[ -z "$layers_output" ]]; then
                layers_output=$(jq -r '.Layers[]' "$manifest_file" 2>/dev/null || true)
            fi

            # For Docker archive format, layers may be in "blobs/sha256/" paths - extract just the hash
            if [[ -n "$layers_output" ]]; then
                # If layers have path prefixes (like "blobs/sha256/"), extract just the hash
                layers_output=$(echo "$layers_output" | awk -F'/' '{print $NF}')
            fi
        elif jq -e '.Layers' "$manifest_file" >/dev/null 2>&1; then
            # Another possible Docker manifest format
            verbose "Processing Docker manifest (alternative format): $manifest_file"
            layers_output=$(jq -r '.Layers[]' "$manifest_file" 2>/dev/null || true)
            if [[ -n "$layers_output" ]]; then
                layers_output=$(echo "$layers_output" | awk -F'/' '{print $NF}')
            fi
        else
            # Fallback for unknown manifest format - check for blobs
            verbose "Processing unknown manifest format: $manifest_file"
            local manifest_dir="${manifest_file%/*}"
            local blob_dir=$(find "$manifest_dir" -name "blobs" -type d 2>/dev/null | head -1)
            if [[ -n "$blob_dir" ]]; then
                layers_output=$(find "$blob_dir" -type f -name "sha256:*" 2>/dev/null | head -10 | awk -F/ '{print $NF}' | sed 's/sha256://' || true)
            fi
        fi
    fi

    if [[ -z "$layers_output" ]]; then
        error "Failed to extract layer list from manifest or blob directory" $EXIT_OPERATION_FAILED
    fi

    verbose "Found layers: $layers_output"
    echo "$layers_output"
}

# ============================================================================
# Delta Creation Functions
# ============================================================================

# Create delta for a single layer
create_layer_delta() {
    local old_layer="$1"
    local new_layer="$2"
    local delta_file="$3"

    # Create directory for delta file if it doesn't exist
    local delta_dir=$(dirname "$delta_file")
    if [[ $DRY_RUN -eq 0 ]]; then
        mkdir -p "$delta_dir" || error "Failed to create delta directory: $delta_dir" $EXIT_OPERATION_FAILED
    fi

    if [[ "$DELTA_METHOD" == "layer" ]]; then
        # Layer method: just copy the layer (no delta)
        verbose "Copying layer (layer method): $new_layer"
        if [[ $DRY_RUN -eq 0 ]]; then
            cp "$new_layer" "$delta_file" || error "Failed to copy layer" $EXIT_OPERATION_FAILED
        fi
    else
        # Use file_delta for xdelta3 or bsdiff
        verbose "Creating layer delta ($DELTA_METHOD): $old_layer -> $new_layer"
        verbose "Command: file_delta -m \"$DELTA_METHOD\" -c \"$COMPRESSION\" -l \"$COMPRESSION_LEVEL\" create \"$old_layer\" \"$new_layer\" \"$delta_file\""

        # Debug: Check if files exist
        if [[ -f "$old_layer" ]]; then
            verbose "✅ Old layer exists: $old_layer (size: $(du -h "$old_layer" | cut -f1))"
        else
            verbose "❌ Old layer not found: $old_layer"
        fi

        if [[ -f "$new_layer" ]]; then
            verbose "✅ New layer exists: $new_layer (size: $(du -h "$new_layer" | cut -f1))"
        else
            verbose "❌ New layer not found: $new_layer"
        fi

        # Debug: Check file access
        if [[ -r "$old_layer" ]]; then
            verbose "✅ Old layer is readable"
        else
            verbose "❌ Old layer is not readable"
        fi

        if [[ -r "$new_layer" ]]; then
            verbose "✅ New layer is readable"
        else
            verbose "❌ New layer is not readable"
        fi

        if [[ $DRY_RUN -eq 0 ]]; then
            # Capture error output properly
            set +e

            # Test file_delta with debug flags
            verbose "\n=== Testing file_delta with debug ==="
            verbose "Command: file_delta -v -m \"$DELTA_METHOD\" -c \"$COMPRESSION\" -l \"$COMPRESSION_LEVEL\" create \"$old_layer\" \"$new_layer\" \"$delta_file\""

            # Capture all output including stderr
            local output
            output=$(file_delta -v -m "$DELTA_METHOD" -c "$COMPRESSION" -l "$COMPRESSION_LEVEL" create \
                "$old_layer" "$new_layer" "$delta_file" 2>&1)
            local exit_code=$?

            if [[ $exit_code -ne 0 ]]; then
                verbose "❌ file_delta exited with code $exit_code"
                verbose "Full output from file_delta:"
                echo "$output" | while IFS= read -r line; do
                    verbose "$line"
                done

                # Test if file_delta can be executed at all
                verbose "\n=== Testing file_delta basic functionality ==="
                local test_output
                touch /tmp/empty_test_old
                echo "test content" > /tmp/empty_test_new
                test_output=$(./file_delta -v create /tmp/empty_test_old /tmp/empty_test_new /tmp/empty_test_delta 2>&1)
                local test_exit=$?
                verbose "file_delta basic test exit code: $test_exit"
                if [[ $test_exit -eq 0 ]]; then
                    verbose "✅ file_delta basic functionality works"
                    rm -f /tmp/empty_test_old /tmp/empty_test_new /tmp/empty_test_delta
                else
                    verbose "❌ file_delta basic functionality failed"
                    verbose "Error: $test_output"
                fi

                # Test if copying works
                verbose "\n=== Testing file copy ==="
                if cp "$new_layer" "$delta_file"; then
                    verbose "✅ Copying layer works fine"
                    ls -la "$delta_file"
                else
                    verbose "❌ Copying layer failed"
                fi

                error "Failed to create layer delta (file_delta exited with code $exit_code)" $EXIT_OPERATION_FAILED
            fi
            set -e
        fi
    fi
}

# Create delta package between two Docker images (base and target)
create_delta_package() {
    local base_image="${1:-}"
    local target_image="$2"
    local delta_package="$3"

    if [[ -z "$base_image" ]]; then
        info "Creating delta package from baseline to image: $target_image"
        base_image=""
    else
        info "Creating delta package from $base_image to $target_image"
    fi

    # Create temporary directories for extraction
    local base_temp_dir=$(mktemp -d)
    local target_temp_dir=$(mktemp -d)
    trap "rm -rf '$base_temp_dir' '$target_temp_dir'" EXIT

    # Extract base image if provided
    local base_layers
    if [[ -n "$base_image" ]]; then
        extract_image_layers "$base_image" "$base_temp_dir"

        # Get base manifest and layer list
        local base_manifest_file=$(get_image_manifest "$base_temp_dir")
        base_layers=$(get_layer_list "$base_manifest_file")
    fi

    # Extract target image
    extract_image_layers "$target_image" "$target_temp_dir"

    # Get target manifest and layer list
    local target_manifest_file=$(get_image_manifest "$target_temp_dir")
    local target_layers=$(get_layer_list "$target_manifest_file")

    # If manifest is an index (multi-arch), use the actual image manifest
    if jq -e '.manifests' "$target_manifest_file" >/dev/null 2>&1; then
        verbose "Resolving nested OCI index manifest"
        target_manifest_file=$(get_image_manifest "$target_temp_dir")
    fi

    # Create delta package directory
    local delta_dir=$(mktemp -d)
    trap "rm -rf '$delta_dir'" EXIT
    mkdir -p "$delta_dir/layer_deltas"

    # Copy target manifest and repositories
    if [[ -f "$target_manifest_file" ]]; then
        # If target manifest is an index (OCI format), extract the actual image manifest to include in delta
        if jq -e '.manifests' "$target_manifest_file" >/dev/null 2>&1; then
            verbose "Manifest is an index - extracting actual image manifest"

            # This is an OCI index - get the actual manifest file
            local manifest_digest=""

            # Try to find manifest matching platform (if specified)
            if [[ -n "$PLATFORM_ARCH" && -n "$PLATFORM_OS" ]]; then
                manifest_digest=$(jq -r --arg os "$PLATFORM_OS" --arg arch "$PLATFORM_ARCH" \
                    '.manifests[] | select(.platform.os == $os and .platform.architecture == $arch) | .digest' "$target_manifest_file" 2>/dev/null | cut -d: -f2 || true)
            fi

            # If no platform specified or no matching manifest, use first amd64/linux manifest
            if [[ -z "$manifest_digest" ]]; then
                manifest_digest=$(jq -r \
                    '.manifests[] | select(.platform.os == "linux" and .platform.architecture == "amd64") | .digest' "$target_manifest_file" 2>/dev/null | cut -d: -f2 || true)
            fi

            # If still no manifest, use first manifest in list
            if [[ -z "$manifest_digest" ]]; then
                manifest_digest=$(jq -r '.manifests[0].digest' "$target_manifest_file" 2>/dev/null | cut -d: -f2 || true)
            fi

            if [[ -n "$manifest_digest" ]]; then
                local actual_manifest_file="${target_manifest_file%/*}/blobs/sha256/${manifest_digest}"
                if [[ -f "$actual_manifest_file" ]]; then
                    cp "$actual_manifest_file" "$delta_dir/manifest.json" || error "Failed to copy actual manifest" $EXIT_OPERATION_FAILED
                    verbose "Copied actual manifest: $actual_manifest_file -> $delta_dir/manifest.json"
                else
                    error "Actual manifest file not found: $actual_manifest_file" $EXIT_OPERATION_FAILED
                fi
            else
                error "No valid manifest found in index file" $EXIT_OPERATION_FAILED
            fi
        else
            # This is an actual image manifest - copy it directly
            cp "$target_manifest_file" "$delta_dir/manifest.json" || error "Failed to copy manifest" $EXIT_OPERATION_FAILED
            verbose "Copied image manifest: $target_manifest_file -> $delta_dir/manifest.json"
        fi
    else
        error "Manifest file not found at $target_manifest_file" $EXIT_OPERATION_FAILED
    fi

    if [[ -f "$target_temp_dir/repositories" ]]; then
        cp "$target_temp_dir/repositories" "$delta_dir/repositories" || error "Failed to copy repositories" $EXIT_OPERATION_FAILED
    fi

    # Create metadata
    cat > "$delta_dir/metadata.json" << EOF
{
    "version": "$VERSION",
    "delta_method": "$DELTA_METHOD",
    "compression": "$COMPRESSION",
    "compression_level": $COMPRESSION_LEVEL,
    "base_image": "${base_image:-}",
    "target_image": "$target_image",
    "created_at": "$(date -Iseconds)"
}
EOF

    # Process each target layer
    local layer_count=0
    while IFS= read -r target_layer; do
        if [[ -n "$target_layer" ]]; then
            layer_count=$((layer_count + 1))

            # Determine layer file path based on format
            local target_layer_file=""
            local is_oci_format=0

            # Check if this is OCI format (has blobs directory)
            if [[ -d "$target_temp_dir/blobs" ]]; then
                is_oci_format=1
                target_layer_file="$target_temp_dir/blobs/sha256/$target_layer"
            else
                target_layer_file="$target_temp_dir/$target_layer"
            fi

            local delta_file="$delta_dir/layer_deltas/${target_layer}.delta"

            info "Processing layer $layer_count: $target_layer"

            # Verify layer file exists
            if [[ ! -f "$target_layer_file" ]]; then
                error "Layer file not found: $target_layer_file" $EXIT_OPERATION_FAILED
            fi

            # Find corresponding base layer if available
            local base_layer_file=""
            if [[ -n "$base_image" ]]; then
                # Try to find layer with same digest in base image
                for base_layer in $base_layers; do
                    if [[ "$base_layer" == "$target_layer" ]]; then
                        if [[ $is_oci_format -eq 1 ]]; then
                            base_layer_file="$base_temp_dir/blobs/sha256/$base_layer"
                        else
                            base_layer_file="$base_temp_dir/$base_layer"
                        fi
                        break
                    fi
                done
            fi

            if [[ -z "$base_layer_file" ]]; then
                if [[ "$DELTA_METHOD" == "layer" ]]; then
                    # No base layer - copy full layer
                    create_layer_delta "" "$target_layer_file" "$delta_file"
                else
                    # No base layer - use empty file
                    local empty_file
                    empty_file=$(mktemp)
                    trap "rm -f '$empty_file'" EXIT
                    create_layer_delta "$empty_file" "$target_layer_file" "$delta_file"
                    rm -f "$empty_file"
                fi
            else
                # Base layer found - create delta
                create_layer_delta "$base_layer_file" "$target_layer_file" "$delta_file"
            fi
        fi
    done <<< "$target_layers"

    # Create the delta package tar
    info "Creating delta package: $delta_package"

    if [[ $DRY_RUN -eq 0 ]]; then
        # Handle existing delta package
        if [ -e "$delta_package" ]; then
            if [[ $FORCE -eq 1 ]]; then
                verbose "Removing existing delta package: $delta_package"
                rm -f "$delta_package"
            else
                error "Delta package already exists: $delta_package. Use -f to force overwrite." $EXIT_INVALID_INPUT
            fi
        fi

        # Create tar archive
        tar -czf "$delta_package" -C "$delta_dir" . || error "Failed to create delta package" $EXIT_OPERATION_FAILED

        # Get package size
        local package_size
        package_size=$(du -h "$delta_package" | cut -f1)
        info "Delta package created: $delta_package ($package_size)"
        info "Layers processed: $layer_count"
    fi
}

# ============================================================================
# Delta Application Functions
# ============================================================================

# Apply delta to reconstruct a layer
apply_layer_delta() {
    local old_layer="$1"
    local delta_file="$2"
    local new_layer="$3"

    # Debug info
    verbose "apply_layer_delta params:"
    verbose "  old_layer: $old_layer"
    verbose "  delta_file: $delta_file"
    verbose "  new_layer: $new_layer"

    if [[ -f "$old_layer" ]]; then
        verbose "✅ Old layer exists: $old_layer (size: $(du -h "$old_layer" | cut -f1))"
    else
        verbose "❌ Old layer not found: $old_layer"
    fi

    if [[ -f "$delta_file" ]]; then
        verbose "✅ Delta file exists: $delta_file (size: $(du -h "$delta_file" | cut -f1))"
    else
        verbose "❌ Delta file not found: $delta_file"
    fi

    if [[ -d "$(dirname "$new_layer")" ]]; then
        verbose "✅ Output directory exists: $(dirname "$new_layer")"
    else
        verbose "❌ Output directory does not exist: $(dirname "$new_layer")"
        mkdir -p "$(dirname "$new_layer")" || error "Failed to create output directory" $EXIT_OPERATION_FAILED
    fi

    if [[ "$DELTA_METHOD" == "layer" ]]; then
        # Layer method: just copy the delta (which is the layer itself)
        verbose "Copying layer (layer method): $delta_file -> $new_layer"
        if [[ $DRY_RUN -eq 0 ]]; then
            cp "$delta_file" "$new_layer" || error "Failed to copy layer" $EXIT_OPERATION_FAILED
        fi
    else
        # Use file_delta to apply delta
        verbose "Applying layer delta ($DELTA_METHOD): $old_layer + $delta_file -> $new_layer"

        if [[ $DRY_RUN -eq 0 ]]; then
            # Apply delta using file_delta with verbose output
            verbose "Executing file_delta: file_delta -v -m \"$DELTA_METHOD\" apply \"$old_layer\" \"$delta_file\" \"$new_layer\""
            set +e
            local file_delta_output
            file_delta_output=$(file_delta -v -m "$DELTA_METHOD" apply "$old_layer" "$delta_file" "$new_layer" 2>&1)
            local file_delta_exit=$?
            set -e

            verbose "file_delta output:"
            verbose "$file_delta_output"

            if [[ $file_delta_exit -ne 0 ]]; then
                error "Failed to apply layer delta (exit code: $file_delta_exit)" $EXIT_OPERATION_FAILED
            fi
        fi
    fi
}

# Apply delta package to reconstruct Docker image
apply_delta_package() {
    local delta_package="$1"
    local image_name="${2:-}"

    info "Applying delta package: $delta_package"

    # Check if delta package exists
    if [[ ! -f "$delta_package" ]]; then
        error "Delta package not found: $delta_package" $EXIT_INVALID_INPUT
    fi

    # Create temporary directory for extraction
    local temp_dir
    temp_dir=$(mktemp -d)
    trap "rm -rf '$temp_dir'" EXIT

    # Extract delta package
    verbose "Extracting delta package"
    tar -xzf "$delta_package" -C "$temp_dir" || error "Failed to extract delta package" $EXIT_OPERATION_FAILED

    # Read metadata
    local metadata_file="$temp_dir/metadata.json"
    if [[ ! -f "$metadata_file" ]]; then
        error "metadata.json not found in delta package" $EXIT_OPERATION_FAILED
    fi

    # Extract delta method from metadata
    local package_delta_method
    package_delta_method=$(python3 -c "
import json
with open('$metadata_file', 'r') as f:
    metadata = json.load(f)
    print(metadata.get('delta_method', 'xdelta3'))
" 2>/dev/null)

    # Extract compression from metadata
    local package_compression
    package_compression=$(python3 -c "
import json
with open('$metadata_file', 'r') as f:
    metadata = json.load(f)
    print(metadata.get('compression', 'zstd'))
" 2>/dev/null)
    local package_compression_level
    package_compression_level=$(python3 -c "
import json
with open('$metadata_file', 'r') as f:
    metadata = json.load(f)
    print(metadata.get('compression_level', 9))
" 2>/dev/null)

    verbose "Delta method: $package_delta_method"
    verbose "Compression: $package_compression level $package_compression_level"

    # Get manifest
    local manifest_file="$temp_dir/manifest.json"
    if [[ ! -f "$manifest_file" ]]; then
        error "manifest.json not found in delta package" $EXIT_OPERATION_FAILED
    fi

    # Get layer list from manifest
    local layers
    layers=$(get_layer_list "$manifest_file")

    # Create image directory for reconstruction
    local image_dir
    image_dir=$(mktemp -d)
    trap "rm -rf '$image_dir'" EXIT

    # Process each layer delta
    local layer_count=0
    while IFS= read -r layer; do
        if [[ -n "$layer" ]]; then
            layer_count=$((layer_count + 1))
            local delta_file="$temp_dir/layer_deltas/${layer}.delta"
            local layer_file="$image_dir/$layer"

            info "Reconstructing layer $layer_count: $layer"

            if [[ "$package_delta_method" == "layer" ]]; then
                # Layer method: just copy the delta (which is the layer itself)
                apply_layer_delta "" "$delta_file" "$layer_file"
            else
                # For xdelta3/bsdiff, we need an old version to apply delta
                # Since we don't have an old version, we'll use an empty file as baseline
                local empty_file
                empty_file=$(mktemp)
                trap "rm -f '$empty_file'" EXIT

                apply_layer_delta "$empty_file" "$delta_file" "$layer_file"
                rm -f "$empty_file"
            fi
        fi
    done <<< "$layers"

    # Create Docker-compatible manifest
    verbose "Creating Docker-compatible manifest"
    local config_digest
    config_digest=$(jq -r '.config.digest' "$manifest_file" 2>/dev/null | sed 's/sha256://' || true)
    local config_file="blobs/sha256/$config_digest"

    local docker_manifest='['
    docker_manifest+=$(jq -c --arg config "$config_file" --arg tag "${image_name:-hello-world:latest}" '
        {
            "Config": $config,
            "RepoTags": [$tag],
            "Layers": [.layers[].digest | sub("sha256:"; "blobs/sha256/")]
        }
    ' "$manifest_file" 2>/dev/null || true)
    docker_manifest+=']'

    # Create blobs directory structure and copy layer files
    mkdir -p "$image_dir/blobs/sha256"
    while IFS= read -r layer; do
        if [[ -n "$layer" ]]; then
            local source_layer="$image_dir/$layer"
            local target_layer="$image_dir/blobs/sha256/$layer"
            mv "$source_layer" "$target_layer" || error "Failed to move layer" $EXIT_OPERATION_FAILED
        fi
    done <<< "$layers"

    # Write Docker manifest
    echo "$docker_manifest" > "$image_dir/manifest.json" || error "Failed to write Docker manifest" $EXIT_OPERATION_FAILED

    # Create index.json (required for newer Docker versions)
    cat > "$image_dir/index.json" <<EOF
{
    "schemaVersion": 2,
    "mediaType": "application/vnd.oci.image.index.v1+json",
    "manifests": [
        {
            "mediaType": "application/vnd.oci.image.index.v1+json",
            "digest": "sha256:$(sha256sum "$image_dir/manifest.json" | awk '{print $1}')",
            "size": $(stat -c%s "$image_dir/manifest.json")
        }
    ]
}
EOF

    # Create repositories file (required for docker load)
    # Get base repository name and tag
    local repo_name="hello-world"
    local tag_name="latest"
    if [[ -n "$image_name" ]]; then
        # Split name into repository and tag
        if [[ "$image_name" =~ ^([^:]+)(:([^:]+))?$ ]]; then
            repo_name="${BASH_REMATCH[1]}"
            if [[ -n "${BASH_REMATCH[3]}" ]]; then
                tag_name="${BASH_REMATCH[3]}"
            fi
        else
            repo_name="$image_name"
        fi
    fi

    # Use the image ID from metadata if available
    local image_id="05813aedc15fb7b4d732e1be879d3252c1c9c25d885824f6295cab4538cb85cd"
    local original_image_id
    original_image_id=$(python3 -c "
import json
with open('$metadata_file', 'r') as f:
    metadata = json.load(f)
    print(metadata.get('original_image_id', ''))
" 2>/dev/null || true)
    if [[ -n "$original_image_id" ]]; then
        image_id="$original_image_id"
    fi

    echo "{\"$repo_name\": {\"$tag_name\": \"sha256:$image_id\"}}" > "$image_dir/repositories"

    # Create OCI layout (required for newer Docker versions)
    echo '{"imageLayoutVersion": "1.0.0"}' > "$image_dir/oci-layout"

    # Create tar archive for docker load
    local image_tar
    image_tar=$(mktemp)
    trap "rm -f '$image_tar'" EXIT

    info "Creating Docker image tar"
    tar -cf "$image_tar" -C "$image_dir" . || error "Failed to create image tar" $EXIT_OPERATION_FAILED

    # Debug: check tar contents
    verbose "Tar contents:"
    tar -tvf "$image_tar"

    # Load the image
    info "Loading Docker image"
    if [[ $DRY_RUN -eq 0 ]]; then
        # Debug: try to load and see error
        set +e
        local docker_load_output
        docker_load_output=$(docker load -i "$image_tar" 2>&1)
        local docker_load_exit=$?
        set -e
        verbose "Docker load output: $docker_load_output"
        if [[ $docker_load_exit -ne 0 ]]; then
            error "Failed to load Docker image (exit code: $docker_load_exit)" $EXIT_OPERATION_FAILED
        fi

        # Extract loaded image ID from output
        local loaded_image_id
        loaded_image_id=$(echo "$docker_load_output" | grep -oP '(?<=Loaded image ID: )sha256:[a-f0-9]+' || true)

        # Get the image name from metadata if not provided
        if [[ -z "$image_name" ]]; then
            image_name=$(python3 -c "
import json
with open('$metadata_file', 'r') as f:
    metadata = json.load(f)
    print(metadata.get('image_name', ''))
")
        fi

        # If we have an image name, tag it
        if [[ -n "$image_name" ]]; then
            if [[ -n "$loaded_image_id" ]]; then
                verbose "Tagging loaded image: $loaded_image_id -> $image_name"
                set +e
                docker tag "$loaded_image_id" "$image_name" 2>/dev/null
                local tag_status=$?
                set -e
                if [[ $tag_status -eq 0 ]]; then
                    info "Tagged successfully: $image_name"
                else
                    verbose "Failed to tag image; using image ID: $loaded_image_id"
                    info "Image loaded successfully: $loaded_image_id"
                fi
            else
                verbose "No image ID found in docker load output; skipping tagging"
                info "Image loaded successfully"
            fi
        else
            if [[ -n "$loaded_image_id" ]]; then
                info "Image loaded successfully: $loaded_image_id"
            else
                info "Image loaded successfully"
            fi
        fi
    fi
}

# ============================================================================
# Delta Package Info Functions
# ============================================================================

# List layers in delta package
list_delta_package() {
    local delta_package="$1"

    if [[ ! -f "$delta_package" ]]; then
        error "Delta package not found: $delta_package" $EXIT_INVALID_INPUT
    fi

    # Create temporary directory for extraction
    local temp_dir
    temp_dir=$(mktemp -d)
    trap "rm -rf '$temp_dir'" EXIT

    # Extract delta package
    tar -xzf "$delta_package" -C "$temp_dir" || error "Failed to extract delta package" $EXIT_OPERATION_FAILED

    # Read metadata
    local metadata_file="$temp_dir/metadata.json"
    if [[ -f "$metadata_file" ]]; then
        info "Delta Package Metadata:"
        cat "$metadata_file" | python3 -m json.tool 2>/dev/null || cat "$metadata_file"
        echo ""
    fi

    # Get manifest
    local manifest_file="$temp_dir/manifest.json"
    if [[ ! -f "$manifest_file" ]]; then
        error "manifest.json not found in delta package" $EXIT_OPERATION_FAILED
    fi

    # List layers
    info "Layers in delta package:"
    local layer_count=0
    local layers
    layers=$(get_layer_list "$manifest_file")

    while IFS= read -r layer; do
        if [[ -n "$layer" ]]; then
            layer_count=$((layer_count + 1))
            local delta_file="$temp_dir/layer_deltas/${layer}.delta"
            local delta_size
            if [[ -f "$delta_file" ]]; then
                delta_size=$(du -h "$delta_file" | cut -f1)
            else
                delta_size="N/A"
            fi
            echo "  $layer_count. $layer ($delta_size)"
        fi
    done <<< "$layers"

    info "Total layers: $layer_count"
}

# Show delta package info
show_delta_info() {
    local delta_package="$1"

    if [[ ! -f "$delta_package" ]]; then
        error "Delta package not found: $delta_package" $EXIT_INVALID_INPUT
    fi

    # Get package size
    local package_size
    package_size=$(du -h "$delta_package" | cut -f1)

    info "Delta Package: $delta_package"
    info "Size: $package_size"

    # Create temporary directory for extraction
    local temp_dir
    temp_dir=$(mktemp -d)
    trap "rm -rf '$temp_dir'" EXIT

    # Extract delta package
    tar -xzf "$delta_package" -C "$temp_dir" || error "Failed to extract delta package" $EXIT_OPERATION_FAILED

    # Read metadata
    local metadata_file="$temp_dir/metadata.json"
    if [[ -f "$metadata_file" ]]; then
        info "Metadata:"
        cat "$metadata_file" | python3 -m json.tool 2>/dev/null || cat "$metadata_file"
    fi
}

# ============================================================================
# CLI Interface
# ============================================================================

# Print usage information
usage() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS] ACTION [ARGS...]

Docker image delta transfer utility for efficient offline transfers.
Transfers only changed layers instead of complete images.

Actions:
  create [BASE_IMAGE] TARGET_IMAGE DELTA_PACKAGE    Create delta package
    Without BASE_IMAGE: Creates delta from baseline to TARGET_IMAGE
    With BASE_IMAGE: Creates delta between two images (BASE and TARGET)

  apply DELTA_PACKAGE [IMAGE_NAME]   Apply delta package to reconstruct image
  list DELTA_PACKAGE                 List layers in delta package
  info DELTA_PACKAGE                 Show delta package metadata

Delta Methods:
  xdelta3   Binary delta for each layer (default, smallest transfer size)
  bsdiff    High-quality delta for large layer changes
  layer     Transfer complete layer files (no delta, just compression)

Options:
  -m, --method METHOD        Delta method: xdelta3 (default), bsdiff, layer
  -c, --compression FORMAT   Compress delta: zstd (default), gzip, bzip2, xz, none
  -l, --level LEVEL          Compression level (1-9, or -1 to -100 for zstd fast mode)
  -s, --source-format FORMAT Source image format for local files: docker-archive, oci-archive
  -t, --target-format FORMAT Output format for reconstructed images: docker-archive, oci-archive
  -p, --platform OS/ARCH     Specify platform for multi-arch images
  -v, --verbose              Show detailed operation info
  -d, --dry-run              Simulate operation without making changes
  -f, --force                Overwrite existing delta/target files
  -h, --help                 Display this help message
  --version                  Show script version

Examples:
  # Create delta from baseline to target image
  $0 create nginx:latest nginx.delta.tar.gz

  # Create delta between two specific images
  $0 create nginx:1.23 nginx:1.24 nginx-update.delta.tar.gz

  # Apply delta package to reconstruct image
  $0 apply nginx.delta.tar.gz

  # List layers in delta package
  $0 list nginx.delta.tar.gz

  # Create delta from OCI archive file
  $0 -s oci-archive create nginx.oci.tar.gz nginx.delta.tar.gz

  # Apply delta to create OCI archive file
  $0 -t oci-archive apply nginx.delta.tar.gz nginx-updated.oci.tar.gz

  # Specify platform for multi-arch image
  $0 -p linux/arm64 create myapp:latest myapp-arm64.delta.tar.gz

Dependencies:
  Required: docker, tar, file_delta, python3 (for JSON parsing)
  Optional: zstd, gzip, bzip2, xz, skopeo (for local file operations)

Notes:
  - When working with local image files (not in Docker daemon), Skopeo is required
  - For local files, supports Docker archive (.tar) and OCI archive (.tar.gz) formats
  - Layer method transfers complete layers without delta encoding
  - Use 'list' action to preview layers before applying
EOF
    exit $EXIT_SUCCESS
}

# Parse command-line arguments
parse_args() {
    # Pre-process combined short options like -vd -> -v -d
    local args=()
    while [[ $# -gt 0 ]]; do
        if [[ "$1" =~ ^-[^-].{2,}$ ]]; then
            local flags="${1:1}"
            for ((i=0; i<${#flags}; i++)); do
                args+=("-"${flags:$i:1})
            done
        else
            args+=("$1")
        fi
        shift
    done

    # Add new options for Skopeo integration
    TEMP=$(getopt -o m:c:l:s:t:p:vdfh --long method:,compression:,level:,source-format:,target-format:,platform:,verbose,dry-run,force,help,version -n "$0" -- "${args[@]}")

    if [ $? != 0 ] ; then error "Terminating..." $EXIT_ERROR ; exit $EXIT_ERROR ; fi

    eval set -- "$TEMP"

    while true; do
        case "$1" in
            -m|--method)
                DELTA_METHOD="$2"
                shift 2
                ;;
            -c|--compression)
                COMPRESSION="$2"
                shift 2
                ;;
            -l|--level)
                COMPRESSION_LEVEL="$2"
                shift 2
                ;;
            -s|--source-format)
                SOURCE_FORMAT="$2"
                shift 2
                ;;
            -t|--target-format)
                TARGET_FORMAT="$2"
                shift 2
                ;;
            -p|--platform)
                # Parse platform in format os/arch
                PLATFORM_OS=${2%%/*}
                PLATFORM_ARCH=${2#*/}
                shift 2
                ;;
            -v|--verbose)
                VERBOSE=1
                shift
                ;;
            -d|--dry-run)
                DRY_RUN=1
                shift
                ;;
            -f|--force)
                FORCE=1
                shift
                ;;
            -h|--help)
                usage
                ;;
            --version)
                echo "docker_delta version $VERSION"
                exit $EXIT_SUCCESS
                ;;
            --)
                shift
                break
                ;;
            *)
                error "Internal error!" $EXIT_ERROR
                ;;
        esac
    done

    if [ $# -lt 1 ]; then
        error "Missing action. Use -h for help." $EXIT_INVALID_INPUT
    fi

    ACTION="$1"
    shift

    case "$ACTION" in
        create)
            if [ $# -lt 2 ]; then
                error "Missing arguments for create. Use -h for help." $EXIT_INVALID_INPUT
            elif [ $# -eq 3 ]; then
                # create base_image target_image delta_package
                BASE_IMAGE="$1"
                TARGET_IMAGE="$2"
                DELTA_PACKAGE="$3"
            elif [ $# -eq 2 ]; then
                # create target_image delta_package (no base)
                BASE_IMAGE=""
                TARGET_IMAGE="$1"
                DELTA_PACKAGE="$2"
            else
                error "Invalid number of arguments for create. Use either:\n  create TARGET_IMAGE DELTA_PACKAGE\n  create BASE_IMAGE TARGET_IMAGE DELTA_PACKAGE" $EXIT_INVALID_INPUT
            fi
            ;;
        apply)
            if [ $# -lt 1 ]; then
                error "Missing arguments for apply. Use -h for help." $EXIT_INVALID_INPUT
            fi
            DELTA_PACKAGE="$1"
            # Optional image name for reconstruction
            if [[ $# -ge 2 ]]; then
                RECONSTRUCTED_IMAGE="$2"
            else
                RECONSTRUCTED_IMAGE=""
            fi
            ;;
        list|info)
            if [ $# -lt 1 ]; then
                error "Missing arguments for $ACTION. Use -h for help." $EXIT_INVALID_INPUT
            fi
            DELTA_PACKAGE="$1"
            ;;
        *)
            error "Invalid action: $ACTION. Must be 'create', 'apply', 'list', or 'info'." $EXIT_INVALID_INPUT
            ;;
    esac
}

# Main function
main() {
    local BASE_IMAGE=""
    local TARGET_IMAGE=""
    local DELTA_PACKAGE=""
    local RECONSTRUCTED_IMAGE=""
    local ACTION=""

    parse_args "$@"
    validate_inputs
    setup_environment

    verbose "docker_delta version $VERSION"
    verbose "Action: $ACTION"
    verbose "Delta Method: $DELTA_METHOD"
    verbose "Compression: $COMPRESSION"
    if [[ "$COMPRESSION" != "none" ]]; then
        verbose "Compression Level: $COMPRESSION_LEVEL"
    fi

    case "$ACTION" in
        create)
            create_delta_package "$BASE_IMAGE" "$TARGET_IMAGE" "$DELTA_PACKAGE"
            ;;
        apply)
            apply_delta_package "$DELTA_PACKAGE" "$RECONSTRUCTED_IMAGE"
            ;;
        list)
            list_delta_package "$DELTA_PACKAGE"
            ;;
        info)
            show_delta_info "$DELTA_PACKAGE"
            ;;
    esac

    if [[ $DRY_RUN -eq 1 ]]; then
        verbose "Dry run completed successfully"
    else
        verbose "Operation completed successfully"
    fi
}

# Run the script
main "$@"

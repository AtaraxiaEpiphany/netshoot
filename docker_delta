#!/usr/bin/env bash
set -euo pipefail

# Docker image delta transfer utility
# Efficiently transfer Docker images by delta encoding layers
# Supports xdelta3, bsdiff, and layer-only transfer methods

VERSION="1.0.0"

# ============================================================================
# Configuration and Constants
# ============================================================================

# Default settings
DELTA_METHOD="xdelta3"  # Choices: xdelta3, bsdiff, layer
VERBOSE=0
DRY_RUN=0
FORCE=0
COMPRESSION="zstd"  # Compress delta files: zstd, gzip, bzip2, xz, none
COMPRESSION_LEVEL=9

# Skopeo integration settings
USE_SKEPEO=0              # Flag for using Skopeo (0 = Docker daemon, 1 = local file)
IMAGE_FILE=""              # Path to local image file
SOURCE_FORMAT=""           # Source format: docker-archive, oci-archive
TARGET_FORMAT=""           # Target format: docker-archive, oci-archive
PLATFORM_ARCH=""           # Architecture for multi-arch images
PLATFORM_OS=""            # OS for multi-arch images

# Supported methods and formats
SUPPORTED_METHODS="xdelta3|bsdiff|layer"
SUPPORTED_COMPRESSION="zstd|gzip|bzip2|xz|none"

# Compression level ranges
ZSTD_MIN_LEVEL=-100
ZSTD_MAX_LEVEL=22
STD_MIN_LEVEL=1
STD_MAX_LEVEL=9

# Exit codes
EXIT_SUCCESS=0
EXIT_ERROR=1
EXIT_MISSING_DEPS=2
EXIT_INVALID_INPUT=3
EXIT_OPERATION_FAILED=4

# Color output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'       # No Color

# ============================================================================
# Logging Functions
# ============================================================================

# Error logging
error() {
    local exit_code=${2:-$EXIT_ERROR}
    echo -e "${RED}[ERROR]${NC} $1" >&2
    exit $exit_code
}

# Info logging
info() {
    echo -e "${GREEN}[INFO]${NC} $*"
}

# Verbose logging
verbose() {
    [[ $VERBOSE -eq 1 ]] && echo -e "${BLUE}[VERBOSE]${NC} $*" >&2
}

# ============================================================================
# Utility Functions
# ============================================================================

# Check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# ============================================================================
# Image Source Detection Functions
# ============================================================================

# Detect if image source is a local file or Docker daemon image
detect_image_source() {
    local source="$1"
    # Remove quotes if present
    local cleaned_source=$(echo "$source" | tr -d '"')

    # Debug: Show what we're checking
    verbose "Checking if '$cleaned_source' exists as a file..."
    if [[ -f "$cleaned_source" ]]; then
        USE_SKEPEO=1
        IMAGE_FILE="$cleaned_source"
        verbose "Detected local image file: $cleaned_source"
    else
        USE_SKEPEO=0
        verbose "Detected Docker daemon image: $source"
    fi
}

# Detect image file format based on file extension
detect_image_format() {
    local file="$1"

    if [[ "$file" == *.tar.gz ]] || [[ "$file" == *.tgz ]]; then
        echo "oci-archive"
    elif [[ "$file" == *.tar ]]; then
        echo "docker-archive"
    else
        # Default to docker-archive for unknown extensions
        echo "docker-archive"
    fi
}

# Get Skopeo transport URL for image file
get_skopeo_transport() {
    local file="$1"
    local format="${2:-}"

    if [[ -z "$format" ]]; then
        format=$(detect_image_format "$file")
    fi

    echo "${format}://${file}"
}

# ============================================================================
# Validation Functions
# ============================================================================

# Validate compression level based on format
validate_compression_level() {
    local format="$1"
    local level="$2"

    if [[ "$format" == "none" ]]; then
        return 0
    fi

    if [[ "$format" == "zstd" ]]; then
        if [[ "$level" -lt $ZSTD_MIN_LEVEL || "$level" -gt $ZSTD_MAX_LEVEL ]]; then
            error "Zstd level must be between $ZSTD_MIN_LEVEL and $ZSTD_MAX_LEVEL" $EXIT_INVALID_INPUT
        fi
    else
        if [[ "$level" -lt $STD_MIN_LEVEL || "$level" -gt $STD_MAX_LEVEL ]]; then
            error "Compression level must be between $STD_MIN_LEVEL and $STD_MAX_LEVEL" $EXIT_INVALID_INPUT
        fi
    fi
}

# Setup environment and check dependencies
setup_environment() {
    local missing_tools=()

    # Check required tools for Docker daemon operations
    if [[ $USE_SKEPEO -eq 0 ]]; then
        if ! command_exists "docker"; then
            missing_tools+=("docker")
        fi
    fi

    if ! command_exists "tar"; then
        missing_tools+=("tar")
    fi

    # Check file_delta in PATH or current directory
    if ! command_exists "file_delta"; then
        # Check if file_delta exists in script directory
        local script_dir
        script_dir=$(dirname "$(realpath "$0")")

        if [[ -x "$script_dir/file_delta" ]]; then
            PATH="$script_dir:$PATH"
            verbose "Using file_delta from script directory"
        else
            missing_tools+=("file_delta")
        fi
    fi

    # Check Skopeo for local file operations
    if [[ $USE_SKEPEO -eq 1 ]]; then
        if ! command_exists "skopeo"; then
            error "Skopeo is required for local image file operations" $EXIT_MISSING_DEPS
        fi
        verbose "Using Skopeo for local image file operations"
    else
        verbose "Using Docker daemon for image operations"
    fi

    if [[ ${#missing_tools[@]} -gt 0 ]]; then
        error "Missing required tools: ${missing_tools[*]}" $EXIT_MISSING_DEPS
    fi

    # Additional dependency check
    if ! command_exists "python3"; then
        error "Python3 is required for JSON processing" $EXIT_MISSING_DEPS
    fi

    verbose "All dependencies verified"
}

# Attempt Docker operation with retries
safe_docker_operation() {
    local cmd="$1"
    local max_retries=3
    local retry_wait=2

    for i in $(seq 1 $max_retries); do
        if $cmd; then
            return 0
        else
            verbose "Docker operation failed (attempt $i/$max_retries), retrying in $retry_wait seconds..."
            sleep $retry_wait
        fi
    done

    error "Docker operation failed after $max_retries attempts" $EXIT_OPERATION_FAILED
}

# Validate inputs
validate_inputs() {
    # Validate delta method
    case "$DELTA_METHOD" in
        xdelta3|bsdiff|layer) ;;
        *) error "Unsupported delta method: $DELTA_METHOD" $EXIT_INVALID_INPUT ;;
    esac

    # Validate compression format
    case "$COMPRESSION" in
        zstd|gzip|bzip2|xz|none) ;;
        *) error "Unsupported compression format: $COMPRESSION" $EXIT_INVALID_INPUT ;;
    esac

    # Validate compression level
    validate_compression_level "$COMPRESSION" "$COMPRESSION_LEVEL"
}

# ============================================================================
# Docker Image Functions
# ============================================================================

# Extract image layers using Skopeo (for local image files)
extract_layers_skopeo() {
    local image_file="$1"
    local extract_dir="$2"
    local format="${3:-}"

    if [[ -z "$format" ]]; then
        format=$(detect_image_format "$image_file")
    fi

    verbose "Extracting layers from local image file: $image_file (format: $format)"

    if [[ $DRY_RUN -eq 0 ]]; then
        mkdir -p "$extract_dir"

        # Debug: Check extract directory creation
        verbose "Created extract directory: $extract_dir"
        ls -la "$extract_dir"

        # Build Skopeo copy command with platform options if specified
        local skopeo_cmd="skopeo copy --dest-tls-verify=false"

        if [[ -n "$PLATFORM_ARCH" ]]; then
            skopeo_cmd="$skopeo_cmd --override-arch=$PLATFORM_ARCH"
        fi

        if [[ -n "$PLATFORM_OS" ]]; then
            skopeo_cmd="$skopeo_cmd --override-os=$PLATFORM_OS"
        fi

        # Copy image to OCI directory format for easier layer access
        # Use absolute path to avoid Skopeo path issues
        local absolute_image_file=$(realpath "$image_file")
        local transport_url="$format://$absolute_image_file"
        local dest_url="oci://$extract_dir"
        verbose "Executing: $skopeo_cmd '$transport_url' '$dest_url'"

        # Execute Skopeo command directly without eval to avoid quote issues
        $skopeo_cmd "$transport_url" "$dest_url" || \
            error "Skopeo copy failed" $EXIT_OPERATION_FAILED

        # Debug: Show what Skopeo created
        verbose "Skopeo copy completed, directory structure:"
        ls -la "$extract_dir"
        find "$extract_dir" -name "*.json" -o -name "*.blob" -o -name "sha256:*" | head -20

        verbose "Image layers extracted to: $extract_dir"
    fi
}

# Get image manifest using Skopeo (for local image files)
get_manifest_skopeo() {
    local image_file="$1"
    local format="${2:-}"

    if [[ -z "$format" ]]; then
        format=$(detect_image_format "$image_file")
    fi

    verbose "Getting manifest from local image file: $image_file"

    local transport_url=$(get_skopeo_transport "$image_file" "$format")

    # Build Skopeo inspect command with platform options if specified
    local skopeo_cmd="skopeo inspect --raw"

    if [[ -n "$PLATFORM_ARCH" ]]; then
        skopeo_cmd="$skopeo_cmd --override-arch=$PLATFORM_ARCH"
    fi

    if [[ -n "$PLATFORM_OS" ]]; then
        skopeo_cmd="$skopeo_cmd --override-os=$PLATFORM_OS"
    fi

    verbose "Executing: $skopeo_cmd '$transport_url'"

    eval "$skopeo_cmd '$transport_url'" || \
        error "Skopeo inspect failed" $EXIT_OPERATION_FAILED
}

# Extract Docker image to temporary directory
extract_image_layers() {
    local image_source="$1"
    local extract_dir="$2"

    # Detect if source is a local file or Docker daemon image
    # Debug: Print image source before detection
    verbose "Image source before detection: '$image_source'"
    detect_image_source "$image_source"

    if [[ $USE_SKEPEO -eq 1 ]]; then
        # Use Skopeo for local image file
        extract_layers_skopeo "$IMAGE_FILE" "$extract_dir" "$SOURCE_FORMAT"
    else
        # Use Docker daemon for loaded image
        verbose "Extracting Docker image: $image_source"

        if [[ $DRY_RUN -eq 0 ]]; then
            mkdir -p "$extract_dir"

            # Enhanced debug logging
            verbose "Working directory: $(pwd)"
            verbose "Docker version: $(docker --version)"
            verbose "Docker image list:"
            docker image list | tee docker_images.log

            # Sanitize image name by removing quotes
            local sanitized_name=$(echo "$image_source" | tr -d '"')

            # Verify image exists first
            verbose "Checking for image: $sanitized_name"
            if ! docker image inspect "$sanitized_name" > /dev/null 2>&1; then
                error "Image '$sanitized_name' not found locally. See docker_images.log for available images." $EXIT_OPERATION_FAILED
            else
                verbose "Image found: $sanitized_name"
                docker image inspect "$sanitized_name" > image_inspect.json
            fi

            # Use sanitized name for all Docker operations
            image_source="$sanitized_name"

            # Create the tar archive with debug output
            verbose "Executing: docker save '$image_source' -o '$extract_dir/image.tar'"
            docker save "$image_source" -o "$extract_dir/image.tar" 2> docker_save_error.log || {
                error "Docker save failed. Error output:\n$(cat docker_save_error.log)\n" $EXIT_OPERATION_FAILED
            }

            # Verify output file
            if [[ ! -f "$extract_dir/image.tar" ]]; then
                error "Image tarball not created: $extract_dir/image.tar" $EXIT_OPERATION_FAILED
            else
                verbose "Image tarball created: $(du -h "$extract_dir/image.tar" | cut -f1)"
            fi

            # Extract tar contents
            # New Docker versions save in OCI format, old in Docker format
            tar -xf "$extract_dir/image.tar" -C "$extract_dir" || error "Failed to extract image tar" $EXIT_OPERATION_FAILED

            # Check for different formats
            if [[ ! -f "$extract_dir/manifest.json" ]] && [[ -f "$extract_dir/index.json" ]]; then
                # This is OCI format - create the expected directories
                mkdir -p "$extract_dir/blobs/sha256"
                mv "$extract_dir"/*.json "$extract_dir/blobs/sha256" 2>/dev/null || true
            fi

            # Remove the tar file after extraction
            rm -f "$extract_dir/image.tar"

            verbose "Image extracted to: $extract_dir"
        fi
    fi
}

# Get image manifest
get_image_manifest() {
    local extract_dir="$1"
    local manifest_file

    # Check if it's OCI format directory structure
    if [[ -f "$extract_dir/index.json" && -d "$extract_dir/blobs" ]]; then
        # Skopeo copies OCI format to this structure
        echo "$extract_dir/index.json"
    # Check if it's Docker format
    elif [[ -f "$extract_dir/manifest.json" ]]; then
        echo "$extract_dir/manifest.json"
    else
        # Search for manifest file in various locations
        manifest_file=$(find "$extract_dir" -name "manifest.json" -o -name "index.json" | head -1)
        if [[ -n "$manifest_file" ]]; then
            echo "$manifest_file"
        else
            error "No manifest found in extracted image at $extract_dir" $EXIT_OPERATION_FAILED
        fi
    fi
}

# Get layer list from manifest
get_layer_list() {
    local manifest_file="$1"
    local layers_output=""

    # Handle case where manifest_file might be empty
    if [[ -z "$manifest_file" ]]; then
        error "No manifest file provided" $EXIT_OPERATION_FAILED
    fi

    # First check if we can find layer blobs directly
    if [[ -f "$manifest_file" ]]; then
        local manifest_dir="${manifest_file%/*}"
        if [[ -n "$manifest_dir" ]]; then
            local blob_dir=$(find "$manifest_dir" -name "blobs" -type d 2>/dev/null | head -1)
            if [[ -n "$blob_dir" ]]; then
                layers_output=$(find "$blob_dir" -type f -name "sha256:*" 2>/dev/null | head -10 | awk -F/ '{print $NF}' | sed 's/sha256://' || true)
            fi
        fi

        # If no layers found, try to parse manifest
        if [[ -z "$layers_output" ]]; then
            # Get actual manifest file if we have an index
            if [[ "$manifest_file" == */index.json ]]; then
                # OCI format index - get the actual manifest
                local manifest_digest=$(jq -r '.manifests[0].digest' "$manifest_file" 2>/dev/null | cut -d: -f2)
                local actual_manifest
                if [[ -n "$manifest_digest" ]]; then
                    actual_manifest="${manifest_file%/*}/blobs/sha256/${manifest_digest}"
                    if [[ -f "$actual_manifest" ]]; then
                        layers_output=$(jq -r '.layers[].digest' "$actual_manifest" 2>/dev/null | sed 's/sha256://' || true)
                    fi
                fi
                # If no layers from manifest, get from index
                if [[ -z "$layers_output" ]]; then
                    layers_output=$(jq -r '.manifests[].digest' "$manifest_file" 2>/dev/null | sed 's/sha256://' || true)
                fi
            elif [[ "$manifest_file" == */manifest.json ]]; then
                # Docker format manifest
                layers_output=$(jq -r '.[0].Layers[]' "$manifest_file" 2>/dev/null || true)
                if [[ -z "$layers_output" ]]; then
                    layers_output=$(jq -r '.Layers[]' "$manifest_file" 2>/dev/null || true)
                fi
            else
                # Fallback for unknown manifest format
                layers_output=$(find "${manifest_file%/*}" -type f -size +1k -o -type f -name "*.blob" | head -10 | awk -F/ '{print $NF}' | sed 's/sha256://' || true)
            fi
        fi
    fi

    if [[ -z "$layers_output" ]]; then
        error "Failed to extract layer list from manifest or blob directory" $EXIT_OPERATION_FAILED
    fi

    echo "$layers_output"
}

# ============================================================================
# Delta Creation Functions
# ============================================================================

# Create delta for a single layer
create_layer_delta() {
    local old_layer="$1"
    local new_layer="$2"
    local delta_file="$3"

    # Create directory for delta file if it doesn't exist
    local delta_dir=$(dirname "$delta_file")
    if [[ $DRY_RUN -eq 0 ]]; then
        mkdir -p "$delta_dir" || error "Failed to create delta directory: $delta_dir" $EXIT_OPERATION_FAILED
    fi

    if [[ "$DELTA_METHOD" == "layer" ]]; then
        # Layer method: just copy the layer (no delta)
        verbose "Copying layer (layer method): $new_layer"
        if [[ $DRY_RUN -eq 0 ]]; then
            cp "$new_layer" "$delta_file" || error "Failed to copy layer" $EXIT_OPERATION_FAILED
        fi
    else
        # Use file_delta for xdelta3 or bsdiff
        verbose "Creating layer delta ($DELTA_METHOD): $old_layer -> $new_layer"

        if [[ $DRY_RUN -eq 0 ]]; then
            # Create delta using file_delta
            file_delta -m "$DELTA_METHOD" -c "$COMPRESSION" -l "$COMPRESSION_LEVEL" create \
                "$old_layer" "$new_layer" "$delta_file" || error "Failed to create layer delta" $EXIT_OPERATION_FAILED
        fi
    fi
}

# Create delta package between two Docker images (base and target)
create_delta_package() {
    local base_image="${1:-}"
    local target_image="$2"
    local delta_package="$3"

    if [[ -z "$base_image" ]]; then
        info "Creating delta package from baseline to image: $target_image"
        base_image=""
    else
        info "Creating delta package from $base_image to $target_image"
    fi

    # Create temporary directories for extraction
    local base_temp_dir=$(mktemp -d)
    local target_temp_dir=$(mktemp -d)
    trap "rm -rf '$base_temp_dir' '$target_temp_dir'" EXIT

    # Extract base image if provided
    local base_layers
    if [[ -n "$base_image" ]]; then
        extract_image_layers "$base_image" "$base_temp_dir"

        # Get base manifest and layer list
        local base_manifest_file=$(get_image_manifest "$base_temp_dir")
        base_layers=$(get_layer_list "$base_manifest_file")
    fi

    # Extract target image
    extract_image_layers "$target_image" "$target_temp_dir"

    # Get target manifest and layer list
    local target_manifest_file=$(get_image_manifest "$target_temp_dir")
    local target_layers=$(get_layer_list "$target_manifest_file")

    # Create delta package directory
    local delta_dir=$(mktemp -d)
    trap "rm -rf '$delta_dir'" EXIT
    mkdir -p "$delta_dir/layer_deltas"

    # Copy target manifest and repositories
    if [[ -f "$target_manifest_file" ]]; then
        cp "$target_manifest_file" "$delta_dir/manifest.json" || error "Failed to copy manifest" $EXIT_OPERATION_FAILED
    else
        error "Manifest file not found at $target_manifest_file" $EXIT_OPERATION_FAILED
    fi

    if [[ -f "$target_temp_dir/repositories" ]]; then
        cp "$target_temp_dir/repositories" "$delta_dir/repositories" || error "Failed to copy repositories" $EXIT_OPERATION_FAILED
    fi

    # Create metadata
    cat > "$delta_dir/metadata.json" << EOF
{
    "version": "$VERSION",
    "delta_method": "$DELTA_METHOD",
    "compression": "$COMPRESSION",
    "compression_level": $COMPRESSION_LEVEL,
    "base_image": "${base_image:-}",
    "target_image": "$target_image",
    "created_at": "$(date -Iseconds)"
}
EOF

    # Process each target layer
    local layer_count=0
    while IFS= read -r target_layer; do
        if [[ -n "$target_layer" ]]; then
            layer_count=$((layer_count + 1))

            # Determine layer file path based on format
            local target_layer_file=""
            local is_oci_format=0

            # Check if this is OCI format (has blobs directory)
            if [[ -d "$target_temp_dir/blobs" ]]; then
                is_oci_format=1
                target_layer_file="$target_temp_dir/blobs/sha256/$target_layer"
            else
                target_layer_file="$target_temp_dir/$target_layer"
            fi

            local delta_file="$delta_dir/layer_deltas/${target_layer}.delta"

            info "Processing layer $layer_count: $target_layer"

            # Verify layer file exists
            if [[ ! -f "$target_layer_file" ]]; then
                error "Layer file not found: $target_layer_file" $EXIT_OPERATION_FAILED
            fi

            # Find corresponding base layer if available
            local base_layer_file=""
            if [[ -n "$base_image" ]]; then
                # Try to find layer with same digest in base image
                for base_layer in $base_layers; do
                    if [[ "$base_layer" == "$target_layer" ]]; then
                        if [[ $is_oci_format -eq 1 ]]; then
                            base_layer_file="$base_temp_dir/blobs/sha256/$base_layer"
                        else
                            base_layer_file="$base_temp_dir/$base_layer"
                        fi
                        break
                    fi
                done
            fi

            if [[ -z "$base_layer_file" ]]; then
                if [[ "$DELTA_METHOD" == "layer" ]]; then
                    # No base layer - copy full layer
                    create_layer_delta "" "$target_layer_file" "$delta_file"
                else
                    # No base layer - use empty file
                    local empty_file
                    empty_file=$(mktemp)
                    trap "rm -f '$empty_file'" EXIT
                    create_layer_delta "$empty_file" "$target_layer_file" "$delta_file"
                    rm -f "$empty_file"
                fi
            else
                # Base layer found - create delta
                create_layer_delta "$base_layer_file" "$target_layer_file" "$delta_file"
            fi
        fi
    done <<< "$target_layers"

    # Create the delta package tar
    info "Creating delta package: $delta_package"

    if [[ $DRY_RUN -eq 0 ]]; then
        # Handle existing delta package
        if [ -e "$delta_package" ]; then
            if [[ $FORCE -eq 1 ]]; then
                verbose "Removing existing delta package: $delta_package"
                rm -f "$delta_package"
            else
                error "Delta package already exists: $delta_package. Use -f to force overwrite." $EXIT_INVALID_INPUT
            fi
        fi

        # Create tar archive
        tar -czf "$delta_package" -C "$delta_dir" . || error "Failed to create delta package" $EXIT_OPERATION_FAILED

        # Get package size
        local package_size
        package_size=$(du -h "$delta_package" | cut -f1)
        info "Delta package created: $delta_package ($package_size)"
        info "Layers processed: $layer_count"
    fi
}

# ============================================================================
# Delta Application Functions
# ============================================================================

# Apply delta to reconstruct a layer
apply_layer_delta() {
    local old_layer="$1"
    local delta_file="$2"
    local new_layer="$3"

    if [[ "$DELTA_METHOD" == "layer" ]]; then
        # Layer method: just copy the delta (which is the layer itself)
        verbose "Copying layer (layer method): $delta_file -> $new_layer"
        if [[ $DRY_RUN -eq 0 ]]; then
            cp "$delta_file" "$new_layer" || error "Failed to copy layer" $EXIT_OPERATION_FAILED
        fi
    else
        # Use file_delta to apply delta
        verbose "Applying layer delta ($DELTA_METHOD): $old_layer + $delta_file -> $new_layer"

        if [[ $DRY_RUN -eq 0 ]]; then
            # Apply delta using file_delta
            file_delta -m "$DELTA_METHOD" apply "$old_layer" "$delta_file" "$new_layer" || \
                error "Failed to apply layer delta" $EXIT_OPERATION_FAILED
        fi
    fi
}

# Apply delta package to reconstruct Docker image
apply_delta_package() {
    local delta_package="$1"
    local image_name="${2:-}"

    info "Applying delta package: $delta_package"

    # Check if delta package exists
    if [[ ! -f "$delta_package" ]]; then
        error "Delta package not found: $delta_package" $EXIT_INVALID_INPUT
    fi

    # Create temporary directory for extraction
    local temp_dir
    temp_dir=$(mktemp -d)
    trap "rm -rf '$temp_dir'" EXIT

    # Extract delta package
    verbose "Extracting delta package"
    tar -xzf "$delta_package" -C "$temp_dir" || error "Failed to extract delta package" $EXIT_OPERATION_FAILED

    # Read metadata
    local metadata_file="$temp_dir/metadata.json"
    if [[ ! -f "$metadata_file" ]]; then
        error "metadata.json not found in delta package" $EXIT_OPERATION_FAILED
    fi

    # Extract delta method from metadata
    local package_delta_method
    package_delta_method=$(python3 -c "
import json
with open('$metadata_file', 'r') as f:
    metadata = json.load(f)
    print(metadata.get('delta_method', 'xdelta3'))
" 2>/dev/null)

    # Extract compression from metadata
    local package_compression
    package_compression=$(python3 -c "
import json
with open('$metadata_file', 'r') as f:
    metadata = json.load(f)
    print(metadata.get('compression', 'zstd'))
" 2>/dev/null)
    local package_compression_level
    package_compression_level=$(python3 -c "
import json
with open('$metadata_file', 'r') as f:
    metadata = json.load(f)
    print(metadata.get('compression_level', 9))
" 2>/dev/null)

    verbose "Delta method: $package_delta_method"
    verbose "Compression: $package_compression level $package_compression_level"

    # Get manifest
    local manifest_file="$temp_dir/manifest.json"
    if [[ ! -f "$manifest_file" ]]; then
        error "manifest.json not found in delta package" $EXIT_OPERATION_FAILED
    fi

    # Get layer list from manifest
    local layers
    layers=$(get_layer_list "$manifest_file")

    # Create image directory for reconstruction
    local image_dir
    image_dir=$(mktemp -d)
    trap "rm -rf '$image_dir'" EXIT

    # Process each layer delta
    local layer_count=0
    while IFS= read -r layer; do
        if [[ -n "$layer" ]]; then
            layer_count=$((layer_count + 1))
            local delta_file="$temp_dir/layer_deltas/${layer}.delta"
            local layer_file="$image_dir/$layer"

            info "Reconstructing layer $layer_count: $layer"

            if [[ "$package_delta_method" == "layer" ]]; then
                # Layer method: just copy the delta (which is the layer itself)
                apply_layer_delta "" "$delta_file" "$layer_file"
            else
                # For xdelta3/bsdiff, we need an old version to apply delta
                # Since we don't have an old version, we'll use an empty file as baseline
                local empty_file
                empty_file=$(mktemp)
                trap "rm -f '$empty_file'" EXIT

                apply_layer_delta "$empty_file" "$delta_file" "$layer_file"
                rm -f "$empty_file"
            fi
        fi
    done <<< "$layers"

    # Copy manifest and repositories
    cp "$manifest_file" "$image_dir/manifest.json" || error "Failed to copy manifest" $EXIT_OPERATION_FAILED
    if [[ -f "$temp_dir/repositories" ]]; then
        cp "$temp_dir/repositories" "$image_dir/repositories" || error "Failed to copy repositories" $EXIT_OPERATION_FAILED
    fi

    # Create tar archive for docker load
    local image_tar
    image_tar=$(mktemp)
    trap "rm -f '$image_tar'" EXIT

    info "Creating Docker image tar"
    tar -cf "$image_tar" -C "$image_dir" . || error "Failed to create image tar" $EXIT_OPERATION_FAILED

    # Load the image
    info "Loading Docker image"
    if [[ $DRY_RUN -eq 0 ]]; then
        docker load -i "$image_tar" || error "Failed to load Docker image" $EXIT_OPERATION_FAILED

        # Get the image name from metadata if not provided
        if [[ -z "$image_name" ]]; then
            image_name=$(python3 -c "
import json
with open('$metadata_file', 'r') as f:
    metadata = json.load(f)
    print(metadata.get('image_name', ''))
")
        fi

        if [[ -n "$image_name" ]]; then
            info "Image loaded successfully: $image_name"
        else
            info "Image loaded successfully"
        fi
    fi
}

# ============================================================================
# Delta Package Info Functions
# ============================================================================

# List layers in delta package
list_delta_package() {
    local delta_package="$1"

    if [[ ! -f "$delta_package" ]]; then
        error "Delta package not found: $delta_package" $EXIT_INVALID_INPUT
    fi

    # Create temporary directory for extraction
    local temp_dir
    temp_dir=$(mktemp -d)
    trap "rm -rf '$temp_dir'" EXIT

    # Extract delta package
    tar -xzf "$delta_package" -C "$temp_dir" || error "Failed to extract delta package" $EXIT_OPERATION_FAILED

    # Read metadata
    local metadata_file="$temp_dir/metadata.json"
    if [[ -f "$metadata_file" ]]; then
        info "Delta Package Metadata:"
        cat "$metadata_file" | python3 -m json.tool 2>/dev/null || cat "$metadata_file"
        echo ""
    fi

    # Get manifest
    local manifest_file="$temp_dir/manifest.json"
    if [[ ! -f "$manifest_file" ]]; then
        error "manifest.json not found in delta package" $EXIT_OPERATION_FAILED
    fi

    # List layers
    info "Layers in delta package:"
    local layer_count=0
    local layers
    layers=$(get_layer_list "$manifest_file")

    while IFS= read -r layer; do
        if [[ -n "$layer" ]]; then
            layer_count=$((layer_count + 1))
            local delta_file="$temp_dir/layer_deltas/${layer}.delta"
            local delta_size
            if [[ -f "$delta_file" ]]; then
                delta_size=$(du -h "$delta_file" | cut -f1)
            else
                delta_size="N/A"
            fi
            echo "  $layer_count. $layer ($delta_size)"
        fi
    done <<< "$layers"

    info "Total layers: $layer_count"
}

# Show delta package info
show_delta_info() {
    local delta_package="$1"

    if [[ ! -f "$delta_package" ]]; then
        error "Delta package not found: $delta_package" $EXIT_INVALID_INPUT
    fi

    # Get package size
    local package_size
    package_size=$(du -h "$delta_package" | cut -f1)

    info "Delta Package: $delta_package"
    info "Size: $package_size"

    # Create temporary directory for extraction
    local temp_dir
    temp_dir=$(mktemp -d)
    trap "rm -rf '$temp_dir'" EXIT

    # Extract delta package
    tar -xzf "$delta_package" -C "$temp_dir" || error "Failed to extract delta package" $EXIT_OPERATION_FAILED

    # Read metadata
    local metadata_file="$temp_dir/metadata.json"
    if [[ -f "$metadata_file" ]]; then
        info "Metadata:"
        cat "$metadata_file" | python3 -m json.tool 2>/dev/null || cat "$metadata_file"
    fi
}

# ============================================================================
# CLI Interface
# ============================================================================

# Print usage information
usage() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS] ACTION [ARGS...]

Docker image delta transfer utility for efficient offline transfers.
Transfers only changed layers instead of complete images.

Actions:
  create [BASE_IMAGE] TARGET_IMAGE DELTA_PACKAGE    Create delta package
    Without BASE_IMAGE: Creates delta from baseline to TARGET_IMAGE
    With BASE_IMAGE: Creates delta between two images (BASE and TARGET)

  apply DELTA_PACKAGE [IMAGE_NAME]   Apply delta package to reconstruct image
  list DELTA_PACKAGE                 List layers in delta package
  info DELTA_PACKAGE                 Show delta package metadata

Delta Methods:
  xdelta3   Binary delta for each layer (default, smallest transfer size)
  bsdiff    High-quality delta for large layer changes
  layer     Transfer complete layer files (no delta, just compression)

Options:
  -m, --method METHOD        Delta method: xdelta3 (default), bsdiff, layer
  -c, --compression FORMAT   Compress delta: zstd (default), gzip, bzip2, xz, none
  -l, --level LEVEL          Compression level (1-9, or -1 to -100 for zstd fast mode)
  -s, --source-format FORMAT Source image format for local files: docker-archive, oci-archive
  -t, --target-format FORMAT Output format for reconstructed images: docker-archive, oci-archive
  -p, --platform OS/ARCH     Specify platform for multi-arch images
  -v, --verbose              Show detailed operation info
  -d, --dry-run              Simulate operation without making changes
  -f, --force                Overwrite existing delta/target files
  -h, --help                 Display this help message
  --version                  Show script version

Examples:
  # Create delta from baseline to target image
  $0 create nginx:latest nginx.delta.tar.gz

  # Create delta between two specific images
  $0 create nginx:1.23 nginx:1.24 nginx-update.delta.tar.gz

  # Apply delta package to reconstruct image
  $0 apply nginx.delta.tar.gz

  # List layers in delta package
  $0 list nginx.delta.tar.gz

  # Create delta from OCI archive file
  $0 -s oci-archive create nginx.oci.tar.gz nginx.delta.tar.gz

  # Apply delta to create OCI archive file
  $0 -t oci-archive apply nginx.delta.tar.gz nginx-updated.oci.tar.gz

  # Specify platform for multi-arch image
  $0 -p linux/arm64 create myapp:latest myapp-arm64.delta.tar.gz

Dependencies:
  Required: docker, tar, file_delta, python3 (for JSON parsing)
  Optional: zstd, gzip, bzip2, xz, skopeo (for local file operations)

Notes:
  - When working with local image files (not in Docker daemon), Skopeo is required
  - For local files, supports Docker archive (.tar) and OCI archive (.tar.gz) formats
  - Layer method transfers complete layers without delta encoding
  - Use 'list' action to preview layers before applying
EOF
    exit $EXIT_SUCCESS
}

# Parse command-line arguments
parse_args() {
    # Pre-process combined short options like -vd -> -v -d
    local args=()
    while [[ $# -gt 0 ]]; do
        if [[ "$1" =~ ^-[^-].{2,}$ ]]; then
            local flags="${1:1}"
            for ((i=0; i<${#flags}; i++)); do
                args+=("-"${flags:$i:1})
            done
        else
            args+=("$1")
        fi
        shift
    done

    # Add new options for Skopeo integration
    TEMP=$(getopt -o m:c:l:s:t:p:vdh --long method:,compression:,level:,source-format:,target-format:,platform:,verbose,dry-run,help,version -n "$0" -- "${args[@]}")

    if [ $? != 0 ] ; then error "Terminating..." $EXIT_ERROR ; exit $EXIT_ERROR ; fi

    eval set -- "$TEMP"

    while true; do
        case "$1" in
            -m|--method)
                DELTA_METHOD="$2"
                shift 2
                ;;
            -c|--compression)
                COMPRESSION="$2"
                shift 2
                ;;
            -l|--level)
                COMPRESSION_LEVEL="$2"
                shift 2
                ;;
            -s|--source-format)
                SOURCE_FORMAT="$2"
                shift 2
                ;;
            -t|--target-format)
                TARGET_FORMAT="$2"
                shift 2
                ;;
            -p|--platform)
                # Parse platform in format os/arch
                PLATFORM_OS=${2%%/*}
                PLATFORM_ARCH=${2#*/}
                shift 2
                ;;
            -v|--verbose)
                VERBOSE=1
                shift
                ;;
            -d|--dry-run)
                DRY_RUN=1
                shift
                ;;
            -f|--force)
                FORCE=1
                shift
                ;;
            -h|--help)
                usage
                ;;
            --version)
                echo "docker_delta version $VERSION"
                exit $EXIT_SUCCESS
                ;;
            --)
                shift
                break
                ;;
            *)
                error "Internal error!" $EXIT_ERROR
                ;;
        esac
    done

    if [ $# -lt 1 ]; then
        error "Missing action. Use -h for help." $EXIT_INVALID_INPUT
    fi

    ACTION="$1"
    shift

    case "$ACTION" in
        create)
            if [ $# -lt 2 ]; then
                error "Missing arguments for create. Use -h for help." $EXIT_INVALID_INPUT
            elif [ $# -eq 3 ]; then
                # create base_image target_image delta_package
                BASE_IMAGE="$1"
                TARGET_IMAGE="$2"
                DELTA_PACKAGE="$3"
            elif [ $# -eq 2 ]; then
                # create target_image delta_package (no base)
                BASE_IMAGE=""
                TARGET_IMAGE="$1"
                DELTA_PACKAGE="$2"
            else
                error "Invalid number of arguments for create. Use either:\n  create TARGET_IMAGE DELTA_PACKAGE\n  create BASE_IMAGE TARGET_IMAGE DELTA_PACKAGE" $EXIT_INVALID_INPUT
            fi
            ;;
        apply)
            if [ $# -lt 1 ]; then
                error "Missing arguments for apply. Use -h for help." $EXIT_INVALID_INPUT
            fi
            DELTA_PACKAGE="$1"
            # Optional image name for reconstruction
            if [[ $# -ge 2 ]]; then
                RECONSTRUCTED_IMAGE="$2"
            else
                RECONSTRUCTED_IMAGE=""
            fi
            ;;
        list|info)
            if [ $# -lt 1 ]; then
                error "Missing arguments for $ACTION. Use -h for help." $EXIT_INVALID_INPUT
            fi
            DELTA_PACKAGE="$1"
            ;;
        *)
            error "Invalid action: $ACTION. Must be 'create', 'apply', 'list', or 'info'." $EXIT_INVALID_INPUT
            ;;
    esac
}

# Main function
main() {
    parse_args "$@"
    validate_inputs
    setup_environment

    verbose "docker_delta version $VERSION"
    verbose "Action: $ACTION"
    verbose "Delta Method: $DELTA_METHOD"
    verbose "Compression: $COMPRESSION"
    if [[ "$COMPRESSION" != "none" ]]; then
        verbose "Compression Level: $COMPRESSION_LEVEL"
    fi

    case "$ACTION" in
        create)
            create_delta_package "$BASE_IMAGE" "$TARGET_IMAGE" "$DELTA_PACKAGE"
            ;;
        apply)
            apply_delta_package "$DELTA_PACKAGE" "$RECONSTRUCTED_IMAGE"
            ;;
        list)
            list_delta_package "$DELTA_PACKAGE"
            ;;
        info)
            show_delta_info "$DELTA_PACKAGE"
            ;;
    esac

    if [[ $DRY_RUN -eq 1 ]]; then
        verbose "Dry run completed successfully"
    else
        verbose "Operation completed successfully"
    fi
}

# Run the script
main "$@"

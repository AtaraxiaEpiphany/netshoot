#!/bin/bash

# file_split - A Unix-style file splitting utility with checksum verification
# Follows Unix philosophy: do one thing well, use pipes, handle errors gracefully

set -u  # Treat unset variables as an error
set -o pipefail  # Pipeline fails if any command fails

# Color codes for logging
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Default values
readonly DEFAULT_OUTPUT_DIR="/tmp"
readonly DEFAULT_CHUNK_PREFIX="chunk_"
readonly MANIFEST_FILE="split_manifest.txt"
readonly CHECKSUM_ALGORITHM="sha256sum"

# Global variables
DRY_RUN=false
OUTPUT_DIR="$DEFAULT_OUTPUT_DIR"
CHUNK_SIZE=""
INPUT_FILE=""
ACTION=""
VERBOSE=false
FORCE=false

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $*"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $*"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $*" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

log_dry_run() {
    if [[ "$DRY_RUN" == true ]]; then
        echo -e "${YELLOW}[DRY RUN]${NC} $*"
    fi
}

# Error handling
error_exit() {
    log_error "$*"
    exit 1
}

# Check if required commands are available
check_dependencies() {
    local commands=("split" "cat" "$CHECKSUM_ALGORITHM" "wc" "stat")
    for cmd in "${commands[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            error_exit "Required command '$cmd' not found"
        fi
    done

    # Check if pv (pipe viewer) is available for progress tracking (optional)
    if command -v pv &> /dev/null; then
        PV_AVAILABLE=true
    else
        PV_AVAILABLE=false
        log_warning "pv (pipe viewer) not found. Progress tracking will be disabled."
    fi
}

# Convert human-readable size to bytes
parse_size() {
    local size="$1"
    local multiplier=1

    # Extract number and unit
    if [[ "$size" =~ ^([0-9]+)([KkMmGg]?)$ ]]; then
        local num="${BASH_REMATCH[1]}"
        local unit="${BASH_REMATCH[2],,}" # Convert to lowercase

        case "$unit" in
            k) multiplier=1024 ;;
            m) multiplier=1048576 ;;
            g) multiplier=1073741824 ;;
            '') multiplier=1 ;;
            *) error_exit "Invalid size unit: $unit. Use K, M, or G" ;;
        esac

        echo $((num * multiplier))
    else
        error_exit "Invalid size format: $size. Use format like 10M, 100K, 1G"
    fi
}

# Validate input file
validate_input_file() {
    if [[ ! -f "$INPUT_FILE" ]]; then
        error_exit "Input file '$INPUT_FILE' does not exist or is not a regular file"
    fi

    if [[ ! -r "$INPUT_FILE" ]]; then
        error_exit "Input file '$INPUT_FILE' is not readable"
    fi

    local file_size=$(stat -c%s "$INPUT_FILE" 2>/dev/null || stat -f%z "$INPUT_FILE")
    if [[ $file_size -eq 0 ]]; then
        error_exit "Input file '$INPUT_FILE' is empty"
    fi
}

# Validate output directory
validate_output_dir() {
    if [[ ! -d "$OUTPUT_DIR" ]]; then
        if [[ "$FORCE" == true ]]; then
            log_info "Creating output directory: $OUTPUT_DIR"
            mkdir -p "$OUTPUT_DIR"
        else
            error_exit "Output directory '$OUTPUT_DIR' does not exist. Use -f to create it"
        fi
    fi

    if [[ ! -w "$OUTPUT_DIR" ]]; then
        error_exit "Output directory '$OUTPUT_DIR' is not writable"
    fi
}

# Generate checksum for a file
generate_checksum() {
    local file="$1"
    if [[ ! -f "$file" ]]; then
        log_error "File not found: $file"
        return 1
    fi
    "$CHECKSUM_ALGORITHM" "$file" | cut -d' ' -f1
}

# Split file into chunks
split_file() {
    local input_file="$1"
    local output_dir="$2"
    local chunk_size="$3"
    local chunk_prefix="$4"

    local manifest_path="$output_dir/$MANIFEST_FILE"
    local original_checksum

    log_info "Splitting file: $input_file"
    log_info "Chunk size: $chunk_size"
    log_info "Output directory: $output_dir"

    # Generate original file checksum
    log_info "Generating checksum for original file..."
    if [[ ! -f "$input_file" ]]; then
        log_error "Input file not found: $input_file"
        return 1
    fi
    original_checksum=$(generate_checksum "$input_file")
    if [[ $? -ne 0 ]]; then
        error_exit "Failed to generate checksum for $input_file"
    fi

    if [[ "$DRY_RUN" == true ]]; then
        log_dry_run "Would split '$input_file' into chunks of $chunk_size in '$output_dir'"
        log_dry_run "Original file checksum: $original_checksum"
        return 0
    fi

    # Create manifest file
    cat > "$manifest_path" << EOF
# File Split Manifest
# Generated by file_split on $(date)
ORIGINAL_FILE=$input_file
ORIGINAL_CHECKSUM=$original_checksum
CHUNK_SIZE=$chunk_size
CHUNK_PREFIX=$chunk_prefix
CHECKSUM_ALGORITHM=$CHECKSUM_ALGORITHM
EOF

    # Get absolute path before changing directory
    local abs_input_file="$(realpath "$input_file")"

    # Split the file with progress tracking
    cd "$output_dir"
    if [[ "$PV_AVAILABLE" == true ]]; then
        log_info "Splitting with progress tracking..."
        pv -pterb "$abs_input_file" | split -b "$chunk_size" - "$chunk_prefix"
    else
        log_info "Splitting without progress tracking..."
        split -b "$chunk_size" "$abs_input_file" "$chunk_prefix"
    fi

    # Generate checksums for each chunk
    local chunk_count=0
    for chunk in "$chunk_prefix"*; do
        if [[ "$chunk" != "$MANIFEST_FILE" ]]; then
            chunk_checksum=$(generate_checksum "$chunk" 2>/dev/null || true)
            if [[ -n "$chunk_checksum" ]]; then
                echo "CHUNK_${chunk_count}=$chunk:$chunk_checksum" >> "$MANIFEST_FILE"
                ((chunk_count++))
            fi
        fi
    done

    echo "TOTAL_CHUNKS=$chunk_count" >> "$MANIFEST_FILE"

    log_success "File split completed successfully"
    log_info "Total chunks created: $chunk_count"
    log_info "Manifest file: $manifest_path"
    log_info "Original file checksum: $original_checksum"
}

# Verify split files and reassemble
verify_and_reassemble() {
    local output_dir="$1"
    local manifest_path="$output_dir/$MANIFEST_FILE"
    local reassembled_file="$output_dir/reassembled_$(basename "$INPUT_FILE")"

    if [[ ! -f "$manifest_path" ]]; then
        error_exit "Manifest file not found in $output_dir. Cannot verify."
    fi

    log_info "Verifying split files in: $output_dir"

    # Read manifest using a safer approach
    local ORIGINAL_FILE ORIGINAL_CHECKSUM CHUNK_SIZE CHUNK_PREFIX MANIFEST_CHECKSUM_ALGORITHM TOTAL_CHUNKS
    declare -A CHUNK_INFO  # Array to store chunk info

    while IFS='=' read -r key value; do
        case "$key" in
            ORIGINAL_FILE) ORIGINAL_FILE="$value" ;;
            ORIGINAL_CHECKSUM) ORIGINAL_CHECKSUM="$value" ;;
            CHUNK_SIZE) CHUNK_SIZE="$value" ;;
            CHUNK_PREFIX) CHUNK_PREFIX="$value" ;;
            CHECKSUM_ALGORITHM) MANIFEST_CHECKSUM_ALGORITHM="$value" ;;
            TOTAL_CHUNKS) TOTAL_CHUNKS="$value" ;;
            CHUNK_*) CHUNK_INFO["$key"]="$value" ;;
        esac
    done < "$manifest_path"

    if [[ -z "${ORIGINAL_FILE:-}" || -z "${ORIGINAL_CHECKSUM:-}" ]]; then
        error_exit "Invalid manifest file: missing required fields"
    fi

    # Verify all chunks exist and checksums match
    local missing_chunks=0
    local checksum_mismatches=0

    for ((i=0; i<${TOTAL_CHUNKS:-0}; i++)); do
        local chunk_key="CHUNK_${i}"
        local chunk_info="${CHUNK_INFO[$chunk_key]:-}"

        if [[ -z "$chunk_info" ]]; then
            log_error "Missing chunk info for chunk $i"
            ((missing_chunks++))
            continue
        fi

        local chunk_file="${chunk_info%:*}"
        local expected_checksum="${chunk_info#*:}"

        if [[ ! -f "$output_dir/$chunk_file" ]]; then
            log_error "Missing chunk file: $chunk_file"
            ((missing_chunks++))
            continue
        fi

        local actual_checksum=$(generate_checksum "$output_dir/$chunk_file")
        if [[ "$actual_checksum" != "$expected_checksum" ]]; then
            log_error "Checksum mismatch for $chunk_file"
            log_error "Expected: $expected_checksum"
            log_error "Actual: $actual_checksum"
            ((checksum_mismatches++))
        fi
    done

    if [[ $missing_chunks -gt 0 || $checksum_mismatches -gt 0 ]]; then
        error_exit "Verification failed: $missing_chunks missing chunks, $checksum_mismatches checksum mismatches"
    fi

    log_success "All chunks verified successfully"

    # Reassemble file
    if [[ "$DRY_RUN" == true ]]; then
        log_dry_run "Would reassemble file to: $reassembled_file"
        return 0
    fi

    log_info "Reassembling file..."
    cat "$output_dir/${CHUNK_PREFIX:-$DEFAULT_CHUNK_PREFIX}"* > "$reassembled_file"

    # Verify reassembled file checksum
    local reassembled_checksum=$(generate_checksum "$reassembled_file")

    if [[ "$reassembled_checksum" == "$ORIGINAL_CHECKSUM" ]]; then
        log_success "File reassembled successfully"
        log_info "Reassembled file: $reassembled_file"
        log_info "Checksum verified: $reassembled_checksum"
    else
        error_exit "Reassembly checksum mismatch!"
    fi
}

# Cleanup generated files
cleanup_files() {
    local output_dir="$1"
    local manifest_path="$output_dir/$MANIFEST_FILE"

    if [[ ! -f "$manifest_path" ]]; then
        error_exit "Manifest file not found in $output_dir. Cannot cleanup."
    fi

    log_info "Cleaning up files in: $output_dir"

    # Read manifest using a safer approach
    local CHUNK_PREFIX TOTAL_CHUNKS
    while IFS='=' read -r key value; do
        case "$key" in
            CHUNK_PREFIX) CHUNK_PREFIX="$value" ;;
            TOTAL_CHUNKS) TOTAL_CHUNKS="$value" ;;
        esac
    done < "$manifest_path"

    if [[ "$DRY_RUN" == true ]]; then
        log_dry_run "Would remove manifest file and all chunk files"
        return 0
    fi

    # Remove chunk files using the prefix from manifest
    if [[ -n "${CHUNK_PREFIX:-}" ]]; then
        rm -f "$output_dir/${CHUNK_PREFIX}"*
    fi

    # Remove manifest and reassembled file if exists
    rm -f "$manifest_path"
    rm -f "$output_dir/reassembled_"*

    log_success "Cleanup completed successfully"
}

# Show usage information
show_usage() {
    cat << EOF
file_split - A Unix-style file splitting utility with checksum verification

Usage: $0 [OPTIONS] ACTION FILE [SIZE]

ACTIONS:
  split      Split FILE into chunks of SIZE (required for split action)
  verify     Verify and reassemble split files in output directory
  cleanup    Remove all generated split files

OPTIONS:
  -d, --dry-run        Show what would be done without making changes
  -o, --output DIR     Output directory (default: $DEFAULT_OUTPUT_DIR)
  -p, --prefix PREFIX  Chunk filename prefix (default: $DEFAULT_CHUNK_PREFIX)
  -f, --force          Create output directory if it doesn't exist
  -v, --verbose        Enable verbose output
  -h, --help           Show this help message

SIZE FORMAT:
  Use K, M, or G suffix for kilobyte, megabyte, or gigabyte
  Examples: 10K, 100M, 1G, 500 (bytes)

EXAMPLES:
  # Split file into 10MB chunks
  $0 split largefile.dat 10M

  # Split with custom output directory and prefix
  $0 -o /tmp/split -p part_ split largefile.dat 100M

  # Verify split files
  $0 verify /tmp/split

  # Cleanup generated files
  $0 cleanup /tmp/split

  # Dry run to see what would happen
  $0 -d split largefile.dat 1G

EOF
}

# Parse command line arguments
parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -d|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -o|--output)
                OUTPUT_DIR="$2"
                shift 2
                ;;
            -p|--prefix)
                CHUNK_PREFIX="$2"
                shift 2
                ;;
            -f|--force)
                FORCE=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -h|--help)
                show_usage
                exit 0
                ;;
            split|verify|cleanup)
                ACTION="$1"
                shift

                if [[ $# -eq 0 ]]; then
                    error_exit "Missing FILE argument for $ACTION action"
                fi

                INPUT_FILE="$1"
                shift

                # For split action, chunk size is required
                if [[ "$ACTION" == "split" ]]; then
                    if [[ $# -eq 0 ]]; then
                        error_exit "Missing SIZE argument for split action"
                    fi
                    CHUNK_SIZE="$1"
                    shift
                fi
                ;;
            *)
                error_exit "Unknown argument: $1"
                ;;
        esac
    done

    # Validate required arguments
    if [[ -z "$ACTION" ]]; then
        error_exit "No action specified. Use 'split', 'verify', or 'cleanup'"
    fi

    if [[ -z "$INPUT_FILE" ]]; then
        error_exit "No input file specified"
    fi

    # Set default chunk prefix if not specified
    if [[ -z "${CHUNK_PREFIX:-}" ]]; then
        CHUNK_PREFIX="$DEFAULT_CHUNK_PREFIX"
    fi
}

# Main function
main() {
    parse_arguments "$@"
    check_dependencies

    if [[ "$VERBOSE" == true ]]; then
        set -x
    fi

    case "$ACTION" in
        split)
            validate_input_file
            validate_output_dir
            split_file "$INPUT_FILE" "$OUTPUT_DIR" "$CHUNK_SIZE" "$CHUNK_PREFIX"
            ;;
        verify)
            validate_output_dir
            verify_and_reassemble "$INPUT_FILE"  # INPUT_FILE is the output dir for verify
            ;;
        cleanup)
            validate_output_dir
            cleanup_files "$INPUT_FILE"  # INPUT_FILE is the output dir for cleanup
            ;;
        *)
            error_exit "Unknown action: $ACTION"
            ;;
    esac
}

# Run main function with all arguments
main "$@"
#!/usr/bin/env bash
set -euo pipefail

VERSION="2.0.0"  # Focused on part generation, checksums, and integrity verification

# Color output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Default settings
SPLIT_SIZE="1G"  # Default split size: 1 Gigabyte
SPLIT_TYPE="size"  # Default split type: size-based
OUTPUT_DIR=""
VERIFY=1  # Always verify by default
CLEANUP=0  # Keep files after verification by default (use --cleanup to remove)
VERBOSE=0
FORCE_NO_CHECKSUM=0  # Advanced: Disable checksum generation (not recommended)

# Error logging
error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
    exit 1
}

# Verbose logging
verbose() {
    [[ $VERBOSE -eq 1 ]] && echo -e "${BLUE}[VERBOSE]${NC} $*" >&2
}

# Print usage information
usage() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS] INPUT_FILE

Split large files into smaller chunks with comprehensive verification.

Split Types:
  size:  Split by file size (default)
  lines: Split by number of lines

Options:
  -s, --size SIZE         Chunk size (default: 1G)
                          Supported formats: K, M, G, T
                          e.g., 100M, 1G, 500K
  -t, --type TYPE         Split type: size or lines (default: size)
  -o, --output DIR        Output directory (default: same as input file)
  -n, --no-verify         Skip file verification (not recommended)
  -c, --cleanup           Remove all generated files (parts + checksums) after successful verification
  -k, --keep-files        Keep generated files even after successful verification (default)
  -v, --verbose           Show detailed information
  -h, --help              Display this help message
  --version               Show script version
  --no-checksum           Disable checksum generation (not recommended for production use)

Features:
  - Mandatory SHA256 checksum generation for every chunk (security by default)
  - Automatic reassembly and integrity verification against original file
  - Optional cleanup of generated files after successful verification
  - Keep files by default for manual inspection or further processing
  - Supports large files with minimal memory usage
  - Comprehensive error handling and verification

Examples:
  $0 largefile.tar.gz                 # Split into 1G chunks with checksums, verify, keep files
  $0 -c largefile.tar.gz              # Split into 1G chunks, verify, then clean up all generated files
  $0 -s 500M largefile.tar.gz         # Split into 500M chunks
  $0 -t lines -s 1000 largefile.txt   # Split into 1000-line chunks
  $0 -o /tmp/splits largefile.tar.gz  # Split to specific directory
  $0 -v largefile.tar.gz             # Verbose split with full details

Security Notes:
  - Checksum generation is enabled by default to prevent data corruption
  - Verification ensures parts can be reassembled to exact original
  - Use --cleanup to automatically remove temporary files after verification
  - Use --no-checksum only for trusted environments with redundant storage

Advanced Verification:
  - Generates SHA256 checksums for each part
  - Reconstructs file to verify total integrity
  - Provides detailed split information
EOF
    exit 0
}

# Check if a command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Validate dependencies
check_dependencies() {
    local dependencies=("split" "shasum" "stat")
    local missing_tools=()

    for tool in "${dependencies[@]}"; do
        if ! command_exists "$tool"; then
            missing_tools+=("$tool")
        fi
    done

    if [[ ${#missing_tools[@]} -gt 0 ]]; then
        error "Missing required tools: ${missing_tools[*]}"
    fi
}

# Parse human-readable size to bytes
parse_size() {
    local size="$1"
    local multiplier=1
    local numeric_part
    local max_size=$((2**63 - 1))  # Max signed 64-bit integer

    # Handle empty input
    if [ -z "$size" ]; then
        error "Size cannot be empty"
    fi

    # Extract numeric and unit parts
    numeric_part=$(echo "$size" | sed -E 's/([0-9.]+)([KMGT]?)/\1/')
    local unit=$(echo "$size" | sed -E 's/([0-9.]+)([KMGT]?)/\2/')

    # Support floating-point values using bc
    if [[ "$numeric_part" == *"."* ]]; then
        numeric_part=$(echo "$numeric_part" | bc)
    fi

    # Validate numeric part
    if [[ ! "$numeric_part" =~ ^[0-9]+$ ]]; then
        error "Invalid numeric part: $numeric_part"
    fi

    # Set multiplier based on unit
    case "$unit" in
        K) multiplier=$((1024)) ;;
        M) multiplier=$((1024 * 1024)) ;;
        G) multiplier=$((1024 * 1024 * 1024)) ;;
        T) multiplier=$((1024 * 1024 * 1024 * 1024)) ;;
        "") multiplier=1 ;;
        *) error "Invalid size unit: $unit" ;;
    esac

    # Calculate bytes
    local calculated_bytes=$((numeric_part * multiplier))

    # Check for overflow
    if [ "$calculated_bytes" -lt 0 ] || [ "$calculated_bytes" -gt "$max_size" ]; then
        error "Size too large: ${size}. Max supported size is $max_size bytes."
    fi

    echo "$calculated_bytes"
}

# Generate checksum for a file
generate_checksum() {
    local file="$1"
    local checksum_file="${file}.sha256"

    # Skip checksum generation if explicitly disabled
    if [ $FORCE_NO_CHECKSUM -eq 1 ]; then
        verbose "Skipping checksum generation for $file (disabled by user)"
        return 0
    fi

    verbose "Generating SHA256 checksum for $file"
    if ! shasum -a 256 "$file" > "$checksum_file"; then
        error "Failed to generate checksum for $file"
    fi
}

# Verify file integrity
verify_file() {
    local file="$1"
    local checksum_file="${file}.sha256"

    # Skip verification if checksums are disabled
    if [ $FORCE_NO_CHECKSUM -eq 1 ]; then
        verbose "Skipping verification for $file (checksums disabled)"
        return 0
    fi

    verbose "Verifying integrity of: $file"
    if [ ! -f "$checksum_file" ]; then
        error "Checksum file not found: $checksum_file. Cannot verify file integrity."
    fi

    if shasum -a 256 -c "$checksum_file"; then
        echo -e "${GREEN}[VERIFIED]${NC} $file"
        return 0
    else
        echo -e "${RED}[CHECKSUM FAILED]${NC} $file"
        return 1
    fi
}

# Calculate number of digits needed for padding
calculate_padding() {
    local total_parts="$1"
    local padding=2
    if [ "$total_parts" -ge 100 ]; then
        padding=3
    fi
    if [ "$total_parts" -ge 1000 ]; then
        padding=4
    fi
    if [ "$total_parts" -ge 10000 ]; then
        padding=5
    fi
    echo "$padding"
}

# Split files by size with improved part numbering
split_by_size() {
    local input_file="$1"
    local output_dir="$2"
    local chunk_size="$3"
    local base_name=$(basename "$input_file")

    # Check available disk space and input file size
    local free_space=$(df -B1 "$output_dir" | awk 'NR==2 {print $4}')
    local input_size=$(stat -c %s "$input_file")

    verbose "Input file size: $input_size bytes"
    verbose "Available space: $free_space bytes"
    verbose "Chunk size: $chunk_size bytes"

    # Calculate total number of parts for proper padding
    local total_parts=$((input_size / chunk_size))
    if [ $((input_size % chunk_size)) -ne 0 ]; then
        total_parts=$((total_parts + 1))
    fi
    local padding=$(calculate_padding "$total_parts")

    # Warn if not enough space for the whole file, but allow splitting
    if [ "$input_size" -gt "$free_space" ]; then
        verbose "${YELLOW}[WARNING]${NC} Insufficient disk space for full file"
        verbose "Will attempt to split, but may not complete all chunks"
    fi

    verbose "Splitting file by size: $chunk_size, $total_parts parts (padding: $padding digits)"

    # Improved splitting with error handling and progress
    local part_number=0
    local remaining_size="$input_size"
    local offset=0
    local total_split_size=0

    while [ "$remaining_size" -gt 0 ]; do
        # Determine chunk size for this iteration
        local current_chunk_size="$chunk_size"
        if [ "$remaining_size" -lt "$chunk_size" ]; then
            current_chunk_size="$remaining_size"
        fi

        # Pad part number to calculated digits
        printf -v part_name "%0${padding}d" "$part_number"
        local output_part="${output_dir}/${base_name}.${part_name}.part"

        verbose "Creating part: $output_part (size: $current_chunk_size bytes)"

        # Simple and reliable byte-by-byte copying (safe for all sizes)
        if ! dd if="$input_file" of="$output_part" bs=1 count="$current_chunk_size" skip="$offset" status=none; then
            error "Failed to create part $part_number"
        fi

        # Verify the part immediately after creation
        local part_size=$(stat -c %s "$output_part")
        if [ "$part_size" -ne "$current_chunk_size" ]; then
            error "Size mismatch in part $part_number. Expected: $current_chunk_size, Actual: $part_size"
        fi

        # Generate and verify checksum for the part immediately
        verbose "Generating checksum for part $part_number"
        generate_checksum "$output_part"
        if ! verify_file "$output_part"; then
            error "Checksum verification failed for part $part_number"
        fi

        # Update tracking variables
        remaining_size=$((remaining_size - current_chunk_size))
        total_split_size=$((total_split_size + part_size))
        offset=$((offset + current_chunk_size))
        part_number=$((part_number + 1))

        # Optional: Log progress
        echo -e "${BLUE}[PROGRESS]${NC} ${part_number}/$total_parts parts, Remaining: $remaining_size bytes" >&2
    done

    verbose "Split completed: $part_number parts created"
    verbose "Total split size: $total_split_size bytes"
    verbose "Original file size: $input_size bytes"

    if [ "$total_split_size" -ne "$input_size" ]; then
        error "Total split size does not match original file size. Original: $input_size, Split: $total_split_size"
    fi
}

# Split files by lines with improved part numbering and verification
split_by_lines() {
    local input_file="$1"
    local output_dir="$2"
    local line_count="$3"
    local base_name=$(basename "$input_file")

    # Calculate total number of lines and parts for proper padding
    local total_lines=$(wc -l < "$input_file")
    local total_parts=$((total_lines / line_count))
    if [ $((total_lines % line_count)) -ne 0 ]; then
        total_parts=$((total_parts + 1))
    fi
    local padding=$(calculate_padding "$total_parts")

    verbose "Splitting file by lines: $line_count, $total_parts parts (padding: $padding digits)"

    split -l "$line_count" \
          -d \
          --additional-suffix=.part \
          "$input_file" \
          "${output_dir}/${base_name}."

    # Rename parts to have proper padding
    local part_number=0
    for part in "${output_dir}/${base_name}".[0-9]*.part; do
        if [ -f "$part" ]; then
            printf -v part_name "%0${padding}d" "$part_number"
            local new_part="${output_dir}/${base_name}.${part_name}.part"
            if [ "$part" != "$new_part" ]; then
                mv "$part" "$new_part"
                verbose "Renamed $part to $new_part"
            fi
            part_number=$((part_number + 1))
        fi
    done

    # Verify each part immediately after creation
    verbose "Verifying all $total_parts parts..."
    local part_number=0
    while [ "$part_number" -lt "$total_parts" ]; do
        printf -v part_name "%0${padding}d" "$part_number"
        local output_part="${output_dir}/${base_name}.${part_name}.part"
        if [ -f "$output_part" ]; then
            verbose "Generating mandatory checksum for part $part_number"
            generate_checksum "$output_part"
            if ! verify_file "$output_part"; then
                error "Checksum verification failed for part $part_number"
            fi
        else
            error "Part $part_number not found: $output_part"
        fi
        part_number=$((part_number + 1))
    done
}

# Parse command-line arguments
parse_args() {
    local TEMP
    TEMP=$(getopt -o s:t:o:nckvh --long size:,type:,output:,no-verify,cleanup,keep-files,verbose,help,version,no-checksum -n "$0" -- "$@")

    if [ $? != 0 ] ; then error "Terminating..." >&2 ; exit 1 ; fi

    eval set -- "$TEMP"

    while true; do
        case "$1" in
            -s|--size)
                SPLIT_SIZE="$2"
                shift 2
                ;;
            -t|--type)
                SPLIT_TYPE="$2"
                shift 2
                ;;
            -o|--output)
                OUTPUT_DIR="$2"
                shift 2
                ;;
            -n|--no-verify)
                VERIFY=0
                shift
                ;;
            -c|--cleanup)
                CLEANUP=1
                shift
                ;;
            -k|--keep-files)
                CLEANUP=0
                shift
                ;;
            -v|--verbose)
                VERBOSE=1
                shift
                ;;
            -h|--help)
                usage
                ;;
            --version)
                echo "file_split version $VERSION"
                exit 0
                ;;
            --no-checksum)
                FORCE_NO_CHECKSUM=1
                shift
                ;;
            --)
                shift
                break
                ;;
            *)
                error "Internal error!"
                ;;
        esac
    done

    # Input file validation
    if [ $# -eq 0 ]; then
        error "No input file specified. Use -h for help."
    elif [ $# -gt 1 ]; then
        error "Too many arguments. Use -h for help."
    fi

    INPUT_FILE="$1"

    # Validate input file
    if [ ! -f "$INPUT_FILE" ]; then
        error "Input file does not exist: $INPUT_FILE"
    fi

    # Set output directory
    if [ -z "$OUTPUT_DIR" ]; then
        OUTPUT_DIR=$(dirname "$INPUT_FILE")
    elif [ ! -d "$OUTPUT_DIR" ]; then
        mkdir -p "$OUTPUT_DIR"
    fi

    # Warn about security implications of disabling checksums
    if [ $FORCE_NO_CHECKSUM -eq 1 ]; then
        echo -e "${YELLOW}[WARNING]${NC} Checksum generation is disabled. This is NOT recommended for production use!"
        echo -e "${YELLOW}[WARNING]${NC} You will not be able to verify file integrity after splitting."
    fi
}

# Reassemble and verify file integrity
reassemble_and_verify() {
    local input_file="$1"
    local output_dir="$2"
    local base_name=$(basename "$input_file")
    local original_size=$(stat -c %s "$input_file")
    local original_checksum=$(shasum -a 256 "$input_file" | cut -d ' ' -f 1)

    verbose "Starting reassembly and verification process..."

    # Find all generated parts
    local generated_parts=()
    local error_count=0
    local total_parts=0

    # Enable nullglob to handle case when no matching files are found
    shopt -s nullglob

    for part in "${output_dir}"/${base_name}.[0-9]*.part; do
        if [ -f "$part" ]; then
            # Check if checksum file already exists
            if [ ! -f "${part}.sha256" ]; then
                generate_checksum "$part"
            fi
            ((total_parts++))
            generated_parts+=("$part")

            if ! verify_file "$part"; then
                ((error_count++))
            fi
        fi
    done

    # Restore nullglob
    shopt -u nullglob

    if [ $error_count -gt 0 ]; then
        error "$error_count out of $total_parts parts failed verification"
    fi

    if [ $total_parts -eq 0 ]; then
        error "No parts found for reassembly"
    fi

    # Sort parts to ensure correct order for reassembly (numeric sort)
    local sorted_parts=()
    local part_list=()

    for part in "${generated_parts[@]}"; do
        # Extract part number from filename
        local filename=$(basename "$part" .part)
        local part_number=$(echo "$filename" | sed "s/^${base_name}\.//")
        part_list+=("$part_number:$part")
    done

    # Sort by part number numerically
    IFS=$'\n' sorted_list=($(sort -t ':' -k1,1n <<< "${part_list[*]}"))
    unset IFS

    for item in "${sorted_list[@]}"; do
        sorted_parts+=("${item#*:}")
    done

    # Reconstruct the file
    local reconstructed_file="${output_dir}/${base_name}.reconstructed"
    verbose "Reconstructing file from $total_parts parts..."

    # Concatenate parts with error handling
    if ! cat "${sorted_parts[@]}" > "$reconstructed_file"; then
        error "Failed to concatenate parts for reconstruction"
    fi

    # Verify reconstructed file size matches original
    local reconstructed_size=$(stat -c %s "$reconstructed_file")

    if [ "$original_size" -ne "$reconstructed_size" ]; then
        error "Reconstruction failed: Size mismatch. Original: $original_size bytes, Reconstructed: $reconstructed_size bytes"
    fi

    # Verify reconstructed file checksum
    local reconstructed_checksum=$(shasum -a 256 "$reconstructed_file" | cut -d ' ' -f 1)

    # Print detailed split information
    echo -e "${BLUE}[SPLIT INFO]${NC}"
    echo "Original File: $input_file"
    echo "Original File Size: $original_size bytes"
    echo "Original SHA256 Checksum: $original_checksum"
    echo "Split into $total_parts parts in $output_dir:"
    for part in "${sorted_parts[@]}"; do
        local part_size=$(stat -c %s "$part")
        local part_checksum=$(shasum -a 256 "$part" | cut -d ' ' -f 1)
        echo "  - $(basename "$part"): $part_size bytes (SHA256: ${part_checksum:0:16}...)"
    done

    # Verify reconstruction
    local verification_result=0
    if [ "$original_checksum" == "$reconstructed_checksum" ]; then
        echo -e "${GREEN}[VERIFICATION]${NC} File successfully reconstructed and verified"
        echo "Reconstructed SHA256 Checksum: $reconstructed_checksum"
        rm "$reconstructed_file"
        verification_result=1
    else
        echo -e "${RED}[RECONSTRUCTION FAILED]${NC} Checksum mismatch"
        echo "Original Checksum:      $original_checksum"
        echo "Reconstructed Checksum: $reconstructed_checksum"
        verification_result=0
    fi

    return $verification_result
}

# Clean up generated files and checksums
cleanup_files() {
    local input_file="$1"
    local output_dir="$2"
    local base_name=$(basename "$input_file")

    verbose "Starting cleanup process..."

    # Remove all part files and their checksums
    shopt -s nullglob
    for part in "${output_dir}"/${base_name}.[0-9]*.part; do
        if [ -f "$part" ]; then
            rm -f "$part"
            rm -f "${part}.sha256"
            verbose "Removed $part and ${part}.sha256"
        fi
    done
    shopt -u nullglob

    # Remove original file checksum
    if [ -f "${input_file}.sha256" ]; then
        rm -f "${input_file}.sha256"
        verbose "Removed ${input_file}.sha256"
    fi

    echo -e "${GREEN}[CLEANUP]${NC} All generated files have been removed"
}

# Main function
main() {
    check_dependencies
    parse_args "$@"

    # Calculate split size/lines
    local split_metric
    if [ "$SPLIT_TYPE" == "size" ]; then
        split_metric=$(parse_size "$SPLIT_SIZE")
        split_by_size "$INPUT_FILE" "$OUTPUT_DIR" "$split_metric"
    else
        split_metric="$SPLIT_SIZE"
        split_by_lines "$INPUT_FILE" "$OUTPUT_DIR" "$split_metric"
    fi

    # Generate original file checksum for verification reference
    generate_checksum "$INPUT_FILE"

    # Get total parts count for final message
    local base_name=$(basename "$INPUT_FILE")
    local total_parts=0
    shopt -s nullglob
    for part in "${OUTPUT_DIR}"/${base_name}.[0-9]*.part; do
        ((total_parts++))
    done
    shopt -u nullglob

    # Verify generated files if requested
    if [ $VERIFY -eq 1 ]; then
        echo -e "${GREEN}[SUCCESS]${NC} All $total_parts split files created with checksums"
        echo -e "${BLUE}[VERIFICATION]${NC} Starting reassembly and verification process..."

        if reassemble_and_verify "$INPUT_FILE" "$OUTPUT_DIR"; then
            # Cleanup generated files if requested
            if [ $CLEANUP -eq 1 ]; then
                cleanup_files "$INPUT_FILE" "$OUTPUT_DIR"
                echo -e "${GREEN}[COMPLETE]${NC} File split, verified, and cleaned up successfully"
            else
                echo -e "${GREEN}[COMPLETE]${NC} File split and verified successfully. Parts retained in $OUTPUT_DIR"
            fi
        else
            error "Verification failed - retaining all files for analysis"
        fi
    else
        echo -e "${GREEN}[COMPLETE]${NC} File split into $total_parts parts in $OUTPUT_DIR\n"
        echo -e "${YELLOW}[NOTICE]${NC} Skipping verification. To verify integrity, run: $0 --verify-only $INPUT_FILE"
    fi

    # Export total_parts for use outside the function
    readonly total_parts
}

# Run the script
main "$@"
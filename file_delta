#!/usr/bin/env bash
set -euo pipefail

# Delta transform utility for incremental upgrades
# Supports xdelta3, bsdiff, and rsync for single files and directories
# Follows Unix philosophy: do one thing well with clear options

VERSION="1.0.0"

# Default settings
DELTA_METHOD="xdelta3"  # Choices: xdelta3, bsdiff, rsync
VERBOSE=0
DRY_RUN=0
FORCE=0
COMPRESSION="zstd"  # Compress delta files: zstd, gzip, bzip2, xz, none
COMPRESSION_LEVEL=9

# Color output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'       # No Color

# Error logging
error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
    exit 1
}

# Verbose logging
verbose() {
    [[ $VERBOSE -eq 1 ]] && echo -e "${BLUE}[VERBOSE]${NC} $*" >&2
}

# Check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Setup environment and check dependencies
setup_environment() {
    local required_tools=("xdelta3" "bsdiff" "rsync")
    local missing_tools=()

    for tool in "${required_tools[@]}"; do
        if ! command_exists "$tool"; then
            missing_tools+=("$tool")
        fi
    done

    if [[ ${#missing_tools[@]} -gt 0 ]]; then
        error "Missing delta tools: ${missing_tools[*]}"
    fi

    # Check compression tools if needed
    if [[ "$COMPRESSION" != "none" ]]; then
        local compression_tools=("zstd" "gzip" "bzip2" "xz")
        if ! command_exists "$COMPRESSION"; then
            error "Compression tool not found: $COMPRESSION"
        fi
    fi

    verbose "All dependencies verified"
}

# Create delta for single file using xdelta3
create_xdelta() {
    local old_file="$1"
    local new_file="$2"
    local delta_file="$3"

    verbose "Creating xdelta3 delta from $old_file to $new_file"
    if [[ $DRY_RUN -eq 0 ]]; then
        xdelta3 -e -9 -s "$old_file" "$new_file" "$delta_file" || error "xdelta3 delta creation failed"
    fi
}

# Apply delta for single file using xdelta3
apply_xdelta() {
    local old_file="$1"
    local delta_file="$2"
    local new_file="$3"

    verbose "Applying xdelta3 delta to $old_file"
    if [[ $DRY_RUN -eq 0 ]]; then
        xdelta3 -d -s "$old_file" "$delta_file" "$new_file" || error "xdelta3 delta application failed"
    fi
}

# Create delta for single file using bsdiff
create_bsdiff() {
    local old_file="$1"
    local new_file="$2"
    local delta_file="$3"

    verbose "Creating bsdiff delta from $old_file to $new_file"
    if [[ $DRY_RUN -eq 0 ]]; then
        bsdiff "$old_file" "$new_file" "$delta_file" || error "bsdiff delta creation failed"
    fi
}

# Apply delta for single file using bsdiff
apply_bsdiff() {
    local old_file="$1"
    local delta_file="$2"
    local new_file="$3"

    verbose "Applying bsdiff delta to $old_file"
    if [[ $DRY_RUN -eq 0 ]]; then
        bspatch "$old_file" "$new_file" "$delta_file" || error "bsdiff delta application failed"
    fi
}

# Create delta for directory using rsync
create_rsync_delta() {
    local old_dir="$1"
    local new_dir="$2"
    local delta_dir="$3"

    verbose "Creating rsync delta from $old_dir to $new_dir"
    if [[ $DRY_RUN -eq 0 ]]; then
        mkdir -p "$delta_dir"
        # Use rsync to copy changed/new files from new_dir to delta_dir
        # --checksum: compare files by checksum, not size/time
        # --ignore-existing: skip files that already exist in delta_dir
        rsync -av --checksum --delete "$new_dir/" "$delta_dir/" || error "rsync delta creation failed"
    fi
}

# Apply delta for directory using rsync
apply_rsync_delta() {
    local old_dir="$1"
    local delta_dir="$2"
    local new_dir="$3"

    verbose "Applying rsync delta to $old_dir"
    if [[ $DRY_RUN -eq 0 ]]; then
        mkdir -p "$new_dir"
        rsync -av "$delta_dir/" "$new_dir/" || error "rsync delta application failed"
    fi
}

# Compress delta file
compress_delta() {
    local input_file="$1"
    local output_file="$2"
    local format="$3"
    local level="$4"

    if [[ "$format" == "none" ]]; then
        if [[ "$input_file" != "$output_file" ]]; then
            verbose "Skipping compression"
            if [[ $DRY_RUN -eq 0 ]]; then
                cp "$input_file" "$output_file" || error "File copy failed"
            fi
        fi
        return 0
    fi

    verbose "Compressing delta with $format level $level"
    if [[ $DRY_RUN -eq 0 ]]; then
        case "$format" in
            gzip)
                gzip -$level -c "$input_file" > "$output_file" || error "gzip compression failed"
                ;;
            bzip2)
                bzip2 -$level -c "$input_file" > "$output_file" || error "bzip2 compression failed"
                ;;
            xz)
                xz -$level -c "$input_file" > "$output_file" || error "xz compression failed"
                ;;
            zstd)
                if [[ "$level" -lt 0 ]]; then
                    local fast_level=$((-level))
                    zstd --fast=$fast_level -c "$input_file" > "$output_file" || error "zstd compression failed"
                elif [[ "$level" -gt 19 ]]; then
                    zstd --ultra -$level -c "$input_file" > "$output_file" || error "zstd compression failed"
                else
                    zstd -$level -c "$input_file" > "$output_file" || error "zstd compression failed"
                fi
                ;;
            *)
                error "Unsupported compression format: $format"
                ;;
        esac
    fi
}

# Decompress delta file
decompress_delta() {
    local input_file="$1"
    local output_file="$2"

    verbose "Decompressing delta file $input_file"
    if [[ $DRY_RUN -eq 0 ]]; then
        # Check file type using 'file' command to detect compression
        local file_type=$(file -b "$input_file")

        if echo "$file_type" | grep -q "gzip compressed"; then
            gzip -d -c "$input_file" > "$output_file" || error "gzip decompression failed"
        elif echo "$file_type" | grep -q "bzip2 compressed"; then
            bzip2 -d -c "$input_file" > "$output_file" || error "bzip2 decompression failed"
        elif echo "$file_type" | grep -q "XZ compressed"; then
            xz -d -c "$input_file" > "$output_file" || error "xz decompression failed"
        elif echo "$file_type" | grep -q "Zstandard compressed"; then
            zstd -d -c "$input_file" > "$output_file" || error "zstd decompression failed"
        else
            # Assume uncompressed
            verbose "No compression detected, copying directly"
            cp "$input_file" "$output_file" || error "File copy failed"
        fi
    fi
}

# Check if path is file or directory
get_path_type() {
    local path="$1"
    if [ -f "$path" ]; then
        echo "file"
    elif [ -d "$path" ]; then
        echo "directory"
    else
        error "Path does not exist or is not a file/directory: $path"
    fi
}

# Create delta
create_delta() {
    local old_path="$1"
    local new_path="$2"
    local delta_path="$3"
    local path_type=$(get_path_type "$old_path")

    if [[ $(get_path_type "$new_path") != "$path_type" ]]; then
        error "Old and new paths must be the same type (both files or both directories)"
    fi

    # Handle existing delta path
    if [ -e "$delta_path" ]; then
        if [[ $FORCE -eq 1 ]]; then
            verbose "Removing existing delta path: $delta_path"
            if [[ $DRY_RUN -eq 0 ]]; then
                rm -rf "$delta_path"
            fi
        else
            error "Delta path already exists: $delta_path. Use -f to force overwrite."
        fi
    fi

    if [[ "$path_type" == "file" ]]; then
        # Create file delta
        local temp_delta
        temp_delta=$(mktemp)
        trap "rm -f '$temp_delta'" EXIT
        rm -f "$temp_delta"  # Remove the created file so xdelta3/bsdiff can create it

        case "$DELTA_METHOD" in
            xdelta3)
                create_xdelta "$old_path" "$new_path" "$temp_delta"
                ;;
            bsdiff)
                create_bsdiff "$old_path" "$new_path" "$temp_delta"
                ;;
            rsync)
                error "rsync delta method not supported for single files"
                ;;
            *)
                error "Unsupported delta method: $DELTA_METHOD"
                ;;
        esac

        # Compress delta
        compress_delta "$temp_delta" "$delta_path" "$COMPRESSION" "$COMPRESSION_LEVEL"

    else
        # Create directory delta
        if [[ "$DELTA_METHOD" == "rsync" ]]; then
            create_rsync_delta "$old_path" "$new_path" "$delta_path"
        else
            # For xdelta3/bsdiff on directories, create tar archive first
            verbose "Directory delta requires rsync method. Falling back to rsync."
            create_rsync_delta "$old_path" "$new_path" "$delta_path"
        fi
    fi

    verbose "Delta created successfully: $delta_path"
}

# Apply delta
apply_delta() {
    local old_path="$1"
    local delta_path="$2"
    local new_path="$3"
    local path_type=$(get_path_type "$old_path")

    if [ -e "$new_path" ]; then
        if [[ $FORCE -eq 1 ]]; then
            verbose "Removing existing target path: $new_path"
            if [[ $DRY_RUN -eq 0 ]]; then
                rm -rf "$new_path"
            fi
        else
            error "Target path already exists: $new_path. Use -f to force overwrite."
        fi
    fi

    if [[ "$path_type" == "file" ]]; then
        # Apply file delta
        local temp_delta
        temp_delta=$(mktemp)
        trap "rm -f '$temp_delta'" EXIT

        decompress_delta "$delta_path" "$temp_delta"

        case "$DELTA_METHOD" in
            xdelta3)
                apply_xdelta "$old_path" "$temp_delta" "$new_path"
                ;;
            bsdiff)
                apply_bsdiff "$old_path" "$temp_delta" "$new_path"
                ;;
            rsync)
                error "rsync delta method not supported for single files"
                ;;
            *)
                error "Unsupported delta method: $DELTA_METHOD"
                ;;
        esac

    else
        # Apply directory delta
        if [[ "$DELTA_METHOD" == "rsync" ]]; then
            apply_rsync_delta "$old_path" "$delta_path" "$new_path"
        else
            error "Directory delta application requires rsync method"
        fi
    fi

    verbose "Delta applied successfully: $new_path"
}

# Print usage information
usage() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS] ACTION OLD_PATH NEW_PATH DELTA_PATH

Delta transform utility for incremental upgrades.
Supports xdelta3, bsdiff, and rsync for single files and directories.

Actions:
  create    Create delta from OLD_PATH to NEW_PATH, save to DELTA_PATH
  apply     Apply delta from DELTA_PATH to OLD_PATH, save to NEW_PATH

Delta Methods:
  xdelta3   Best for binary files (default)
  bsdiff    Good for large binary files with significant changes
  rsync     Best for directories (preserves permissions, symlinks)

Options:
  -m, --method METHOD        Delta method: xdelta3 (default), bsdiff, rsync
  -c, --compression FORMAT   Compress delta file: zstd (default), gzip, bzip2, xz, none
  -l, --level LEVEL          Compression level (1-9, or -1 to -100 for zstd fast mode)
  -v, --verbose              Show detailed operation info
  -d, --dry-run              Simulate operation without making changes
  -f, --force                Overwrite existing delta/target files
  -h, --help                 Display this help message
  --version                  Show script version

Combined options:
  Short options can be combined, e.g., '-vd' for verbose + dry-run mode

Examples:
  # Single file delta with xdelta3 (compressed)
  $0 create old.bin new.bin delta.xdelta
  $0 apply old.bin delta.xdelta new.bin

  # Single file delta with bsdiff
  $0 -m bsdiff create old.iso new.iso update.bsdiff

  # Directory delta with rsync (preserves permissions)
  $0 -m rsync create old_dir/ new_dir/ update_rsync/
  $0 -m rsync apply old_dir/ update_rsync/ new_dir/

  # Uncompressed delta
  $0 -c none create old.txt new.txt delta.raw

  # Custom compression level
  $0 -c gzip -l 6 create data.bin new_data.bin delta.gz

  # Verbose dry run
  $0 -vd create old_file new_file delta.test

Dependencies:
  Required: xdelta3, bsdiff (bsdiff/bspatch), rsync
  Optional: zstd, gzip, bzip2, xz (for compression)
EOF
    exit 0
}

# Parse command-line arguments
parse_args() {
    # Pre-process combined short options like -vd -> -v -d
    local args=()
    while [[ $# -gt 0 ]]; do
        if [[ "$1" =~ ^-[^-].{2,}$ ]]; then
            local flags="${1:1}"
            for ((i=0; i<${#flags}; i++)); do
                args+=("-"${flags:$i:1})
            done
        else
            args+=("$1")
        fi
        shift
    done

    TEMP=$(getopt -o m:c:l:vdfh --long method:,compression:,level:,verbose,dry-run,force,help,version -n "$0" -- "${args[@]}")

    if [ $? != 0 ] ; then error "Terminating..." >&2 ; exit 1 ; fi

    eval set -- "$TEMP"

    while true; do
        case "$1" in
            -m|--method)
                DELTA_METHOD="$2"
                shift 2
                ;;
            -c|--compression)
                COMPRESSION="$2"
                shift 2
                ;;
            -l|--level)
                COMPRESSION_LEVEL="$2"
                shift 2
                ;;
            -v|--verbose)
                VERBOSE=1
                shift
                ;;
            -d|--dry-run)
                DRY_RUN=1
                shift
                ;;
            -f|--force)
                FORCE=1
                shift
                ;;
            -h|--help)
                usage
                ;;
            --version)
                echo "file_delta version $VERSION"
                exit 0
                ;;
            --)
                shift
                break
                ;;
            *)
                error "Internal error!"
                ;;
        esac
    done

    if [ $# -lt 4 ]; then
        error "Missing arguments. Use -h for help."
    fi

    ACTION="$1"

    if [[ "$ACTION" == "create" ]]; then
        OLD_PATH="$2"
        NEW_PATH="$3"
        DELTA_PATH="$4"

        if [ ! -e "$OLD_PATH" ]; then
            error "Old path does not exist: $OLD_PATH"
        fi
        if [ ! -e "$NEW_PATH" ]; then
            error "New path does not exist: $NEW_PATH"
        fi
    elif [[ "$ACTION" == "apply" ]]; then
        OLD_PATH="$2"
        DELTA_PATH="$3"
        NEW_PATH="$4"

        if [ ! -e "$OLD_PATH" ]; then
            error "Old path does not exist: $OLD_PATH"
        fi
        if [ ! -e "$DELTA_PATH" ]; then
            error "Delta path does not exist: $DELTA_PATH"
        fi
        # Target path (NEW_PATH) will be created, so don't check if it exists
    else
        error "Invalid action: $ACTION. Must be 'create' or 'apply'."
    fi
}

# Validate inputs
validate_inputs() {
    # Validate delta method
    case "$DELTA_METHOD" in
        xdelta3|bsdiff|rsync) ;;
        *) error "Unsupported delta method: $DELTA_METHOD" ;;
    esac

    # Validate compression format
    case "$COMPRESSION" in
        zstd|gzip|bzip2|xz|none) ;;
        *) error "Unsupported compression format: $COMPRESSION" ;;
    esac

    # Validate compression level
    if [[ "$COMPRESSION" != "none" ]]; then
        if [[ "$COMPRESSION" == "zstd" ]]; then
            if [[ "$COMPRESSION_LEVEL" -lt -100 || "$COMPRESSION_LEVEL" -gt 22 ]]; then
                error "Zstd level must be between -100 and 22"
            fi
        else
            if [[ "$COMPRESSION_LEVEL" -lt 1 || "$COMPRESSION_LEVEL" -gt 9 ]]; then
                error "Compression level must be between 1 and 9"
            fi
        fi
    fi
}

# Main function
main() {
    parse_args "$@"
    validate_inputs
    setup_environment

    verbose "file_delta version $VERSION"
    verbose "Action: $ACTION"
    verbose "Delta Method: $DELTA_METHOD"
    verbose "Compression: $COMPRESSION"
    if [[ "$COMPRESSION" != "none" ]]; then
        verbose "Compression Level: $COMPRESSION_LEVEL"
    fi

    if [[ "$ACTION" == "create" ]]; then
        create_delta "$OLD_PATH" "$NEW_PATH" "$DELTA_PATH"
    elif [[ "$ACTION" == "apply" ]]; then
        apply_delta "$OLD_PATH" "$DELTA_PATH" "$NEW_PATH"
    fi

    if [[ $DRY_RUN -eq 1 ]]; then
        verbose "Dry run completed successfully"
    else
        verbose "Operation completed successfully"
    fi
}

# Run the script
main "$@"
